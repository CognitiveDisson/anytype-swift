// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pb/protos/commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Rpc is a namespace, that agregates all of the service commands between client and middleware.
/// Structure: Topic > Subtopic > Subsub... > Action > (Request, Response).
/// Request – message from a client.
/// Response – message from a middleware.
public struct Anytype_Rpc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ExternalDrop {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Files {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        /// id of the simple block to insert considering position
        public var dropTargetID: String = String()

        /// position relatively to the dropTargetId simple block
        public var position: Anytype_Model_Block.Position = .none

        public var localFilePaths: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.ExternalDrop.Files.Response.Error {
          get {return _error ?? Anytype_Rpc.ExternalDrop.Files.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.ExternalDrop.Files.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.ExternalDrop.Files.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Content {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        /// can be null
        public var focusedBlockID: String = String()

        /// TODO
        public var content: Data = Data()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.ExternalDrop.Content.Response.Error {
          get {return _error ?? Anytype_Rpc.ExternalDrop.Content.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.ExternalDrop.Content.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.ExternalDrop.Content.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct BlockList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ConvertChildrenToPages {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockIds: [String] = []

        public var objectType: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error {
          get {return _error ?? Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var linkIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error? = nil
      }

      public init() {}
    }

    public struct Move {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockIds: [String] = []

        public var targetContextID: String = String()

        /// id of the simple block to insert considering position
        public var dropTargetID: String = String()

        /// position relatively to the dropTargetId simple block
        public var position: Anytype_Model_Block.Position = .none

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.BlockList.Move.Response.Error {
          get {return _error ?? Anytype_Rpc.BlockList.Move.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.BlockList.Move.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.BlockList.Move.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct MoveToNewPage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockIds: [String] = []

        /// page details
        public var details: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_details = newValue}
        }
        /// Returns true if `details` has been explicitly set.
        public var hasDetails: Bool {return self._details != nil}
        /// Clears the value of `details`. Subsequent reads from it will return its default value.
        public mutating func clearDetails() {self._details = nil}

        /// id of the simple block to insert considering position
        public var dropTargetID: String = String()

        /// position relatively to the dropTargetId simple block
        public var position: Anytype_Model_Block.Position = .none

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.BlockList.MoveToNewPage.Response.Error {
          get {return _error ?? Anytype_Rpc.BlockList.MoveToNewPage.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var linkID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.BlockList.MoveToNewPage.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.BlockList.MoveToNewPage.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    ///
    /// Makes blocks copy by given ids and paste it to shown place
    public struct Duplicate {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        /// id of the closest block
        public var targetID: String = String()

        /// id of block for duplicate
        public var blockIds: [String] = []

        public var position: Anytype_Model_Block.Position = .none

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.BlockList.Duplicate.Response.Error {
          get {return _error ?? Anytype_Rpc.BlockList.Duplicate.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockIds: [String] = []

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.BlockList.Duplicate.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.BlockList.Duplicate.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Set {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// commands acceptable only for text blocks, others will be ignored
      public struct Text {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Style {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockIds: [String] = []

            public var style: Anytype_Model_Block.Content.Text.Style = .paragraph

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.BlockList.Set.Text.Style.Response.Error {
              get {return _error ?? Anytype_Rpc.BlockList.Set.Text.Style.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.BlockList.Set.Text.Style.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.BlockList.Set.Text.Style.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public struct Color {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockIds: [String] = []

            public var color: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.BlockList.Set.Text.Color.Response.Error {
              get {return _error ?? Anytype_Rpc.BlockList.Set.Text.Color.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.BlockList.Set.Text.Color.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.BlockList.Set.Text.Color.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public struct Mark {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockIds: [String] = []

            public var mark: Anytype_Model_Block.Content.Text.Mark {
              get {return _mark ?? Anytype_Model_Block.Content.Text.Mark()}
              set {_mark = newValue}
            }
            /// Returns true if `mark` has been explicitly set.
            public var hasMark: Bool {return self._mark != nil}
            /// Clears the value of `mark`. Subsequent reads from it will return its default value.
            public mutating func clearMark() {self._mark = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _mark: Anytype_Model_Block.Content.Text.Mark? = nil
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error {
              get {return _error ?? Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct BackgroundColor {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockIds: [String] = []

          public var color: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error {
            get {return _error ?? Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Align {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// when empty - align will be applied as layoutAlign
          public var blockIds: [String] = []

          public var align: Anytype_Model_Block.Align = .left

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.BlockList.Set.Align.Response.Error {
            get {return _error ?? Anytype_Rpc.BlockList.Set.Align.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.BlockList.Set.Align.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.BlockList.Set.Align.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Fields {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockFields: [Anytype_Rpc.BlockList.Set.Fields.Request.BlockField] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct BlockField {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var blockID: String = String()

            public var fields: SwiftProtobuf.Google_Protobuf_Struct {
              get {return _fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
              set {_fields = newValue}
            }
            /// Returns true if `fields` has been explicitly set.
            public var hasFields: Bool {return self._fields != nil}
            /// Clears the value of `fields`. Subsequent reads from it will return its default value.
            public mutating func clearFields() {self._fields = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
          }

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.BlockList.Set.Fields.Response.Error {
            get {return _error ?? Anytype_Rpc.BlockList.Set.Fields.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.BlockList.Set.Fields.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.BlockList.Set.Fields.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Div {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Style {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockIds: [String] = []

            public var style: Anytype_Model_Block.Content.Div.Style = .line

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.BlockList.Set.Div.Style.Response.Error {
              get {return _error ?? Anytype_Rpc.BlockList.Set.Div.Style.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.BlockList.Set.Div.Style.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.BlockList.Set.Div.Style.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public init() {}
    }

    public struct TurnInto {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockIds: [String] = []

        public var style: Anytype_Model_Block.Content.Text.Style = .paragraph

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.BlockList.TurnInto.Response.Error {
          get {return _error ?? Anytype_Rpc.BlockList.TurnInto.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.BlockList.TurnInto.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.BlockList.TurnInto.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public init() {}
  }

  ///
  /// Namespace, that agregates subtopics and actions, that relates to blocks.
  public struct Block {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Replace {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockID: String = String()

        public var block: Anytype_Model_Block {
          get {return _block ?? Anytype_Model_Block()}
          set {_block = newValue}
        }
        /// Returns true if `block` has been explicitly set.
        public var hasBlock: Bool {return self._block != nil}
        /// Clears the value of `block`. Subsequent reads from it will return its default value.
        public mutating func clearBlock() {self._block = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _block: Anytype_Model_Block? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Replace.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Replace.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Replace.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Replace.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct UpdateContent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockID: String = String()

        public var block: Anytype_Model_Block {
          get {return _block ?? Anytype_Model_Block()}
          set {_block = newValue}
        }
        /// Returns true if `block` has been explicitly set.
        public var hasBlock: Bool {return self._block != nil}
        /// Clears the value of `block`. Subsequent reads from it will return its default value.
        public mutating func clearBlock() {self._block = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _block: Anytype_Model_Block? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.UpdateContent.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.UpdateContent.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.UpdateContent.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.UpdateContent.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Split {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockID: String = String()

        public var range: Anytype_Model_Range {
          get {return _range ?? Anytype_Model_Range()}
          set {_range = newValue}
        }
        /// Returns true if `range` has been explicitly set.
        public var hasRange: Bool {return self._range != nil}
        /// Clears the value of `range`. Subsequent reads from it will return its default value.
        public mutating func clearRange() {self._range = nil}

        public var style: Anytype_Model_Block.Content.Text.Style = .paragraph

        public var mode: Anytype_Rpc.Block.Split.Request.Mode = .bottom

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Mode: SwiftProtobuf.Enum {
          public typealias RawValue = Int

          /// new block will be created under existing
          case bottom // = 0

          /// new block will be created above existing
          case top // = 1

          /// new block will be created as the first children of existing
          case inner // = 2

          /// new block will be created after header (not required for set at client side, will auto set for title block)
          case title // = 3
          case UNRECOGNIZED(Int)

          public init() {
            self = .bottom
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .bottom
            case 1: self = .top
            case 2: self = .inner
            case 3: self = .title
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .bottom: return 0
            case .top: return 1
            case .inner: return 2
            case .title: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}

        fileprivate var _range: Anytype_Model_Range? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Split.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Split.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Split.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Split.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Merge {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var firstBlockID: String = String()

        public var secondBlockID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Merge.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Merge.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Merge.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Merge.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Copy {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blocks: [Anytype_Model_Block] = []

        public var selectedTextRange: Anytype_Model_Range {
          get {return _selectedTextRange ?? Anytype_Model_Range()}
          set {_selectedTextRange = newValue}
        }
        /// Returns true if `selectedTextRange` has been explicitly set.
        public var hasSelectedTextRange: Bool {return self._selectedTextRange != nil}
        /// Clears the value of `selectedTextRange`. Subsequent reads from it will return its default value.
        public mutating func clearSelectedTextRange() {self._selectedTextRange = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _selectedTextRange: Anytype_Model_Range? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Copy.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Copy.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var textSlot: String = String()

        public var htmlSlot: String = String()

        public var anySlot: [Anytype_Model_Block] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Copy.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Copy.Response.Error? = nil
      }

      public init() {}
    }

    public struct Paste {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var focusedBlockID: String = String()

        public var selectedTextRange: Anytype_Model_Range {
          get {return _selectedTextRange ?? Anytype_Model_Range()}
          set {_selectedTextRange = newValue}
        }
        /// Returns true if `selectedTextRange` has been explicitly set.
        public var hasSelectedTextRange: Bool {return self._selectedTextRange != nil}
        /// Clears the value of `selectedTextRange`. Subsequent reads from it will return its default value.
        public mutating func clearSelectedTextRange() {self._selectedTextRange = nil}

        public var selectedBlockIds: [String] = []

        public var isPartOfBlock: Bool = false

        public var textSlot: String = String()

        public var htmlSlot: String = String()

        public var anySlot: [Anytype_Model_Block] = []

        public var fileSlot: [Anytype_Rpc.Block.Paste.Request.File] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct File {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var name: String = String()

          public var data: Data = Data()

          public var localPath: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _selectedTextRange: Anytype_Model_Range? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Paste.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Paste.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockIds: [String] = []

        public var caretPosition: Int32 = 0

        public var isSameBlockCaret: Bool = false

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Paste.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Paste.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Cut {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blocks: [Anytype_Model_Block] = []

        public var selectedTextRange: Anytype_Model_Range {
          get {return _selectedTextRange ?? Anytype_Model_Range()}
          set {_selectedTextRange = newValue}
        }
        /// Returns true if `selectedTextRange` has been explicitly set.
        public var hasSelectedTextRange: Bool {return self._selectedTextRange != nil}
        /// Clears the value of `selectedTextRange`. Subsequent reads from it will return its default value.
        public mutating func clearSelectedTextRange() {self._selectedTextRange = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _selectedTextRange: Anytype_Model_Range? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Cut.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Cut.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var textSlot: String = String()

        public var htmlSlot: String = String()

        public var anySlot: [Anytype_Model_Block] = []

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Cut.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Cut.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct ImportMarkdown {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var importPath: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.ImportMarkdown.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.ImportMarkdown.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var rootLinkIds: [String] = []

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.ImportMarkdown.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.ImportMarkdown.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Export {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blocks: [Anytype_Model_Block] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Export.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Export.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var path: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Export.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Export.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Upload {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockID: String = String()

        public var filePath: String = String()

        public var url: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Upload.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Upload.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Upload.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Upload.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Download {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var blockID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Download.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Download.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Download.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Download.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Set {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Fields {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var fields: SwiftProtobuf.Google_Protobuf_Struct {
            get {return _fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
            set {_fields = newValue}
          }
          /// Returns true if `fields` has been explicitly set.
          public var hasFields: Bool {return self._fields != nil}
          /// Clears the value of `fields`. Subsequent reads from it will return its default value.
          public mutating func clearFields() {self._fields = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Set.Fields.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Set.Fields.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Set.Fields.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Set.Fields.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Details {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Detail {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var key: String = String()

          /// NUll - removes key
          public var value: SwiftProtobuf.Google_Protobuf_Value {
            get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
            set {_value = newValue}
          }
          /// Returns true if `value` has been explicitly set.
          public var hasValue: Bool {return self._value != nil}
          /// Clears the value of `value`. Subsequent reads from it will return its default value.
          public mutating func clearValue() {self._value = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
        }

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var details: [Anytype_Rpc.Block.Set.Details.Detail] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Set.Details.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Set.Details.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Set.Details.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Set.Details.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Restrictions {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var restrictions: Anytype_Model_Block.Restrictions {
            get {return _restrictions ?? Anytype_Model_Block.Restrictions()}
            set {_restrictions = newValue}
          }
          /// Returns true if `restrictions` has been explicitly set.
          public var hasRestrictions: Bool {return self._restrictions != nil}
          /// Clears the value of `restrictions`. Subsequent reads from it will return its default value.
          public mutating func clearRestrictions() {self._restrictions = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _restrictions: Anytype_Model_Block.Restrictions? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Set.Restrictions.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Set.Restrictions.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Set.Restrictions.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Set.Restrictions.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Page {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct IsArchived {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var isArchived: Bool = false

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct Latex {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Text {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var text: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Latex.Text.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Latex.Text.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Latex.Text.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Latex.Text.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct Text {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Text {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var text: String = String()

            public var marks: Anytype_Model_Block.Content.Text.Marks {
              get {return _marks ?? Anytype_Model_Block.Content.Text.Marks()}
              set {_marks = newValue}
            }
            /// Returns true if `marks` has been explicitly set.
            public var hasMarks: Bool {return self._marks != nil}
            /// Clears the value of `marks`. Subsequent reads from it will return its default value.
            public mutating func clearMarks() {self._marks = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _marks: Anytype_Model_Block.Content.Text.Marks? = nil
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Text.Text.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Text.Text.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Text.Text.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Text.Text.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public struct Color {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var color: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Text.Color.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Text.Color.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Text.Color.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Text.Color.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public struct Style {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var style: Anytype_Model_Block.Content.Text.Style = .paragraph

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Text.Style.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Text.Style.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Text.Style.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Text.Style.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public struct Checked {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var checked: Bool = false

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Text.Checked.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Text.Checked.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Text.Checked.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Text.Checked.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct File {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Name {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var name: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.File.Name.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.File.Name.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.File.Name.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.File.Name.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct Image {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Name {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var name: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Image.Name.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Image.Name.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Image.Name.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Image.Name.Response.Error? = nil
          }

          public init() {}
        }

        public struct Width {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var width: Int32 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Image.Width.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Image.Width.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Image.Width.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Image.Width.Response.Error? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct Video {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Name {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var name: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Video.Name.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Video.Name.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Video.Name.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Video.Name.Response.Error? = nil
          }

          public init() {}
        }

        public struct Width {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var width: Int32 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Video.Width.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Video.Width.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Video.Width.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Video.Width.Response.Error? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public struct Link {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct TargetBlockId {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Request {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var contextID: String = String()

            public var blockID: String = String()

            public var targetBlockID: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct Response {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var error: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error {
              get {return _error ?? Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error()}
              set {_error = newValue}
            }
            /// Returns true if `error` has been explicitly set.
            public var hasError: Bool {return self._error != nil}
            /// Clears the value of `error`. Subsequent reads from it will return its default value.
            public mutating func clearError() {self._error = nil}

            public var event: Anytype_ResponseEvent {
              get {return _event ?? Anytype_ResponseEvent()}
              set {_event = newValue}
            }
            /// Returns true if `event` has been explicitly set.
            public var hasEvent: Bool {return self._event != nil}
            /// Clears the value of `event`. Subsequent reads from it will return its default value.
            public mutating func clearEvent() {self._event = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct Error {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var code: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error.Code = .null

              public var description_p: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public enum Code: SwiftProtobuf.Enum {
                public typealias RawValue = Int
                case null // = 0
                case unknownError // = 1

                /// ...
                case badInput // = 2
                case UNRECOGNIZED(Int)

                public init() {
                  self = .null
                }

                public init?(rawValue: Int) {
                  switch rawValue {
                  case 0: self = .null
                  case 1: self = .unknownError
                  case 2: self = .badInput
                  default: self = .UNRECOGNIZED(rawValue)
                  }
                }

                public var rawValue: Int {
                  switch self {
                  case .null: return 0
                  case .unknownError: return 1
                  case .badInput: return 2
                  case .UNRECOGNIZED(let i): return i
                  }
                }

              }

              public init() {}
            }

            public init() {}

            fileprivate var _error: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error? = nil
            fileprivate var _event: Anytype_ResponseEvent? = nil
          }

          public init() {}
        }

        public init() {}
      }

      public init() {}
    }

    public struct Relation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct SetKey {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var key: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Relation.SetKey.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Relation.SetKey.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Relation.SetKey.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Relation.SetKey.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Add {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String {
            get {return _storage._contextID}
            set {_uniqueStorage()._contextID = newValue}
          }

          public var blockID: String {
            get {return _storage._blockID}
            set {_uniqueStorage()._blockID = newValue}
          }

          public var relation: Anytype_Model_Relation {
            get {return _storage._relation ?? Anytype_Model_Relation()}
            set {_uniqueStorage()._relation = newValue}
          }
          /// Returns true if `relation` has been explicitly set.
          public var hasRelation: Bool {return _storage._relation != nil}
          /// Clears the value of `relation`. Subsequent reads from it will return its default value.
          public mutating func clearRelation() {_uniqueStorage()._relation = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _storage = _StorageClass.defaultInstance
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Relation.Add.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Relation.Add.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Relation.Add.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Relation.Add.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public struct ObjectType {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Set {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var objectTypeURL: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.ObjectType.Set.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.ObjectType.Set.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.ObjectType.Set.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case unknownObjectTypeURL // = 3
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                case 3: self = .unknownObjectTypeURL
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .unknownObjectTypeURL: return 3
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.ObjectType.Set.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public struct Bookmark {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Fetch {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var url: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Bookmark.Fetch.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Bookmark.Fetch.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Bookmark.Fetch.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Bookmark.Fetch.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct CreateAndFetch {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var targetID: String = String()

          public var position: Anytype_Model_Block.Position = .none

          public var url: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var blockID: String = String()

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public struct File {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct CreateAndUpload {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var targetID: String = String()

          public var position: Anytype_Model_Block.Position = .none

          public var url: String = String()

          public var localPath: String = String()

          public var fileType: Anytype_Model_Block.Content.File.TypeEnum = .none

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.File.CreateAndUpload.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.File.CreateAndUpload.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var blockID: String = String()

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.File.CreateAndUpload.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.File.CreateAndUpload.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public struct Dataview {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct ViewCreate {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block to insert the new block
          public var blockID: String = String()

          public var view: Anytype_Model_Block.Content.Dataview.View {
            get {return _view ?? Anytype_Model_Block.Content.Dataview.View()}
            set {_view = newValue}
          }
          /// Returns true if `view` has been explicitly set.
          public var hasView: Bool {return self._view != nil}
          /// Clears the value of `view`. Subsequent reads from it will return its default value.
          public mutating func clearView() {self._view = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _view: Anytype_Model_Block.Content.Dataview.View? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var viewID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct ViewUpdate {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block to update
          public var blockID: String = String()

          /// id of view to update
          public var viewID: String = String()

          public var view: Anytype_Model_Block.Content.Dataview.View {
            get {return _view ?? Anytype_Model_Block.Content.Dataview.View()}
            set {_view = newValue}
          }
          /// Returns true if `view` has been explicitly set.
          public var hasView: Bool {return self._view != nil}
          /// Clears the value of `view`. Subsequent reads from it will return its default value.
          public mutating func clearView() {self._view = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _view: Anytype_Model_Block.Content.Dataview.View? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct ViewDelete {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          /// id of the context block
          public var contextID: String = String()

          /// id of the dataview
          public var blockID: String = String()

          /// id of the view to remove
          public var viewID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct ViewSetPosition {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          /// id of the context block
          public var contextID: String = String()

          /// id of the dataview
          public var blockID: String = String()

          /// id of the view to remove
          public var viewID: String = String()

          /// index of view position (0 - means first)
          public var position: UInt32 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      /// set the current active view (persisted only within a session)
      public struct ViewSetActive {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block
          public var blockID: String = String()

          /// id of active view
          public var viewID: String = String()

          public var offset: UInt32 = 0

          public var limit: UInt32 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct RecordUpdate {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var recordID: String = String()

          public var record: SwiftProtobuf.Google_Protobuf_Struct {
            get {return _record ?? SwiftProtobuf.Google_Protobuf_Struct()}
            set {_record = newValue}
          }
          /// Returns true if `record` has been explicitly set.
          public var hasRecord: Bool {return self._record != nil}
          /// Clears the value of `record`. Subsequent reads from it will return its default value.
          public mutating func clearRecord() {self._record = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _record: SwiftProtobuf.Google_Protobuf_Struct? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error? = nil
        }

        public init() {}
      }

      public struct RecordDelete {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var recordID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct RecordCreate {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var record: SwiftProtobuf.Google_Protobuf_Struct {
            get {return _record ?? SwiftProtobuf.Google_Protobuf_Struct()}
            set {_record = newValue}
          }
          /// Returns true if `record` has been explicitly set.
          public var hasRecord: Bool {return self._record != nil}
          /// Clears the value of `record`. Subsequent reads from it will return its default value.
          public mutating func clearRecord() {self._record = nil}

          public var templateID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _record: SwiftProtobuf.Google_Protobuf_Struct? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var record: SwiftProtobuf.Google_Protobuf_Struct {
            get {return _record ?? SwiftProtobuf.Google_Protobuf_Struct()}
            set {_record = newValue}
          }
          /// Returns true if `record` has been explicitly set.
          public var hasRecord: Bool {return self._record != nil}
          /// Clears the value of `record`. Subsequent reads from it will return its default value.
          public mutating func clearRecord() {self._record = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error? = nil
          fileprivate var _record: SwiftProtobuf.Google_Protobuf_Struct? = nil
        }

        public init() {}
      }

      public struct RelationAdd {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String {
            get {return _storage._contextID}
            set {_uniqueStorage()._contextID = newValue}
          }

          /// id of dataview block to add relation
          public var blockID: String {
            get {return _storage._blockID}
            set {_uniqueStorage()._blockID = newValue}
          }

          public var relation: Anytype_Model_Relation {
            get {return _storage._relation ?? Anytype_Model_Relation()}
            set {_uniqueStorage()._relation = newValue}
          }
          /// Returns true if `relation` has been explicitly set.
          public var hasRelation: Bool {return _storage._relation != nil}
          /// Clears the value of `relation`. Subsequent reads from it will return its default value.
          public mutating func clearRelation() {_uniqueStorage()._relation = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _storage = _StorageClass.defaultInstance
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error {
            get {return _storage._error ?? Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error()}
            set {_uniqueStorage()._error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return _storage._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {_uniqueStorage()._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _storage._event ?? Anytype_ResponseEvent()}
            set {_uniqueStorage()._event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return _storage._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {_uniqueStorage()._event = nil}

          /// deprecated
          public var relationKey: String {
            get {return _storage._relationKey}
            set {_uniqueStorage()._relationKey = newValue}
          }

          public var relation: Anytype_Model_Relation {
            get {return _storage._relation ?? Anytype_Model_Relation()}
            set {_uniqueStorage()._relation = newValue}
          }
          /// Returns true if `relation` has been explicitly set.
          public var hasRelation: Bool {return _storage._relation != nil}
          /// Clears the value of `relation`. Subsequent reads from it will return its default value.
          public mutating func clearRelation() {_uniqueStorage()._relation = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _storage = _StorageClass.defaultInstance
        }

        public init() {}
      }

      public struct RelationUpdate {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String {
            get {return _storage._contextID}
            set {_uniqueStorage()._contextID = newValue}
          }

          /// id of dataview block to add relation
          public var blockID: String {
            get {return _storage._blockID}
            set {_uniqueStorage()._blockID = newValue}
          }

          /// key of relation to update
          public var relationKey: String {
            get {return _storage._relationKey}
            set {_uniqueStorage()._relationKey = newValue}
          }

          public var relation: Anytype_Model_Relation {
            get {return _storage._relation ?? Anytype_Model_Relation()}
            set {_uniqueStorage()._relation = newValue}
          }
          /// Returns true if `relation` has been explicitly set.
          public var hasRelation: Bool {return _storage._relation != nil}
          /// Clears the value of `relation`. Subsequent reads from it will return its default value.
          public mutating func clearRelation() {_uniqueStorage()._relation = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _storage = _StorageClass.defaultInstance
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct RelationDelete {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block to add relation
          public var blockID: String = String()

          public var relationKey: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      /// RecordRelationOptionAdd may return existing option in case object specified with recordId already have the option with the same name or ID
      public struct RecordRelationOptionAdd {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block to add relation
          public var blockID: String = String()

          /// relation key to add the option
          public var relationKey: String = String()

          /// id of select options will be autogenerated
          public var option: Anytype_Model_Relation.Option {
            get {return _option ?? Anytype_Model_Relation.Option()}
            set {_option = newValue}
          }
          /// Returns true if `option` has been explicitly set.
          public var hasOption: Bool {return self._option != nil}
          /// Clears the value of `option`. Subsequent reads from it will return its default value.
          public mutating func clearOption() {self._option = nil}

          /// id of record which is used to add an option
          public var recordID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _option: Anytype_Model_Relation.Option? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var option: Anytype_Model_Relation.Option {
            get {return _option ?? Anytype_Model_Relation.Option()}
            set {_option = newValue}
          }
          /// Returns true if `option` has been explicitly set.
          public var hasOption: Bool {return self._option != nil}
          /// Clears the value of `option`. Subsequent reads from it will return its default value.
          public mutating func clearOption() {self._option = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
          fileprivate var _option: Anytype_Model_Relation.Option? = nil
        }

        public init() {}
      }

      public struct RecordRelationOptionUpdate {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block to add relation
          public var blockID: String = String()

          /// relation key to add the option
          public var relationKey: String = String()

          /// id of select options will be autogenerated
          public var option: Anytype_Model_Relation.Option {
            get {return _option ?? Anytype_Model_Relation.Option()}
            set {_option = newValue}
          }
          /// Returns true if `option` has been explicitly set.
          public var hasOption: Bool {return self._option != nil}
          /// Clears the value of `option`. Subsequent reads from it will return its default value.
          public mutating func clearOption() {self._option = nil}

          /// id of record which is used to update an option
          public var recordID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _option: Anytype_Model_Relation.Option? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct RecordRelationOptionDelete {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          /// id of dataview block to add relation
          public var blockID: String = String()

          /// relation key to add the option
          public var relationKey: String = String()

          /// id of select options to remove
          public var optionID: String = String()

          /// id of record which is used to delete an option
          public var recordID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct RelationListAvailable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var relations: [Anytype_Model_Relation] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2

              /// ...
              case notADataviewBlock // = 3
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                case 3: self = .notADataviewBlock
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .notADataviewBlock: return 3
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error? = nil
        }

        public init() {}
      }

      public struct SetSource {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var source: [String] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Dataview.SetSource.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Dataview.SetSource.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Dataview.SetSource.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Dataview.SetSource.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public struct Get {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///
      /// Get marks list in the selected range in text block.
      public struct Marks {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var blockID: String = String()

          public var range: Anytype_Model_Range {
            get {return _range ?? Anytype_Model_Range()}
            set {_range = newValue}
          }
          /// Returns true if `range` has been explicitly set.
          public var hasRange: Bool {return self._range != nil}
          /// Clears the value of `range`. Subsequent reads from it will return its default value.
          public mutating func clearRange() {self._range = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _range: Anytype_Model_Range? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Block.Get.Marks.Response.Error {
            get {return _error ?? Anytype_Rpc.Block.Get.Marks.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Block.Get.Marks.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Block.Get.Marks.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    /// Available undo/redo operations
    public struct UndoRedoCounter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var undo: Int32 = 0

      public var redo: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Undo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Undo.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Undo.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var counters: Anytype_Rpc.Block.UndoRedoCounter {
          get {return _counters ?? Anytype_Rpc.Block.UndoRedoCounter()}
          set {_counters = newValue}
        }
        /// Returns true if `counters` has been explicitly set.
        public var hasCounters: Bool {return self._counters != nil}
        /// Clears the value of `counters`. Subsequent reads from it will return its default value.
        public mutating func clearCounters() {self._counters = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Undo.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// ...
            case canNotMove // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .canNotMove
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .canNotMove: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Undo.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
        fileprivate var _counters: Anytype_Rpc.Block.UndoRedoCounter? = nil
      }

      public init() {}
    }

    public struct Redo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Redo.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Redo.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var counters: Anytype_Rpc.Block.UndoRedoCounter {
          get {return _counters ?? Anytype_Rpc.Block.UndoRedoCounter()}
          set {_counters = newValue}
        }
        /// Returns true if `counters` has been explicitly set.
        public var hasCounters: Bool {return self._counters != nil}
        /// Clears the value of `counters`. Subsequent reads from it will return its default value.
        public mutating func clearCounters() {self._counters = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Redo.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// ...
            case canNotMove // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .canNotMove
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .canNotMove: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Redo.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
        fileprivate var _counters: Anytype_Rpc.Block.UndoRedoCounter? = nil
      }

      public init() {}
    }

    ///
    /// Works with a smart blocks (block-organizers, like page, dashboard etc)
    /// **Example scenario**
    /// 1A. On front-end start.
    ///     1. Front -> MW: Rpc.Block.Open.Request(dashboard.id)
    ///     2. MW -> Front: BlockShow(dashboard)
    ///     3. MW -> Front: Rpc.Block.Open.Response(err)
    /// 1B. User clicks on a page icon on the dashboard.
    ///     1. Front -> MW: Rpc.Block.Close.Request(dashboard.id)
    /// Get close response first, then open request:
    ///     2. MW -> Front: Rpc.Block.Close.Response(err)
    ///     3. Front -> MW: Rpc.Block.Open.Request(page.id)
    ///     4. MW -> Front: BlockShow(<page, blocks>)
    ///     5. MW -> Front: Rpc.Block.Open.Response(err)
    /// Image/Video/File blocks then:
    ///     6. MW -> Front: BlockShow(<blocks>)
    public struct Open {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context blo1k
        public var contextID: String = String()

        public var blockID: String = String()

        public var traceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Open.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Open.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Open.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case notFound // = 3

            /// failed to read unknown data format – need to upgrade anytype
            case anytypeNeedsUpgrade // = 10
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .notFound
              case 10: self = .anytypeNeedsUpgrade
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .notFound: return 3
              case .anytypeNeedsUpgrade: return 10
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Open.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Show {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context blo1k
        public var contextID: String = String()

        public var blockID: String = String()

        public var traceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Show.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Show.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Show.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case notFound // = 3

            /// failed to read unknown data format – need to upgrade anytype
            case anytypeNeedsUpgrade // = 10
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .notFound
              case 10: self = .anytypeNeedsUpgrade
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .notFound: return 3
              case .anytypeNeedsUpgrade: return 10
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Show.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct GetPublicWebURL {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var blockID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.GetPublicWebURL.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.GetPublicWebURL.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var url: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.GetPublicWebURL.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.GetPublicWebURL.Response.Error? = nil
      }

      public init() {}
    }

    public struct OpenBreadcrumbs {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context blo1k
        public var contextID: String = String()

        public var traceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct SetBreadcrumbs {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var breadcrumbsID: String = String()

        /// page ids
        public var ids: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.SetBreadcrumbs.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.SetBreadcrumbs.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.SetBreadcrumbs.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.SetBreadcrumbs.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    ///
    /// Create a Smart/Internal block. Request can contain a block with a content, or it can be an empty block with a specific block.content.
    /// **Example scenario**
    /// 1A. Create Page on a dashboard
    ///     1. Front -> MW: Rpc.Block.Create.Request(blockId:dashboard.id, position:bottom, block: emtpy block with page content and id = "")
    ///     2. Front -> MW: Rpc.Block.Close.Request(block: dashboard.id)
    ///     3. Front <- MW: Rpc.Block.Close.Response(err)
    ///     4. Front <- MW: Rpc.Block.Create.Response(page.id)
    ///     5. Front <- MW: Rpc.Block.Open.Response(err)
    ///     6. Front <- MW: Event.Block.Show(page)
    /// 1B. Create Page on a Page
    ///     1. Front -> MW: Rpc.Block.Create.Request(blockId:dashboard.id, position:bottom, block: emtpy block with page content and id = "")
    ///     2. Front <- MW: Rpc.Block.Create.Response(newPage.id)
    ///     3. Front <- MW: Event.Block.Show(newPage)
    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// common simple block command
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        /// id of the closest block
        public var targetID: String = String()

        public var block: Anytype_Model_Block {
          get {return _block ?? Anytype_Model_Block()}
          set {_block = newValue}
        }
        /// Returns true if `block` has been explicitly set.
        public var hasBlock: Bool {return self._block != nil}
        /// Clears the value of `block`. Subsequent reads from it will return its default value.
        public mutating func clearBlock() {self._block = nil}

        public var position: Anytype_Model_Block.Position = .none

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _block: Anytype_Model_Block? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Create.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct CreatePage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        /// new page details
        public var details: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_details = newValue}
        }
        /// Returns true if `details` has been explicitly set.
        public var hasDetails: Bool {return self._details != nil}
        /// Clears the value of `details`. Subsequent reads from it will return its default value.
        public mutating func clearDetails() {self._details = nil}

        /// optional template id for creating from template
        public var templateID: String = String()

        /// link block params
        public var targetID: String = String()

        public var position: Anytype_Model_Block.Position = .none

        /// link block fields
        public var fields: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _fields ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_fields = newValue}
        }
        /// Returns true if `fields` has been explicitly set.
        public var hasFields: Bool {return self._fields != nil}
        /// Clears the value of `fields`. Subsequent reads from it will return its default value.
        public mutating func clearFields() {self._fields = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
        fileprivate var _fields: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.CreatePage.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.CreatePage.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var blockID: String = String()

        public var targetID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.CreatePage.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.CreatePage.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct CreateSet {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        /// id of the closest block
        public var targetID: String = String()

        public var source: [String] = []

        /// details
        public var details: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_details = newValue}
        }
        /// Returns true if `details` has been explicitly set.
        public var hasDetails: Bool {return self._details != nil}
        /// Clears the value of `details`. Subsequent reads from it will return its default value.
        public mutating func clearDetails() {self._details = nil}

        public var position: Anytype_Model_Block.Position = .none

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.CreateSet.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.CreateSet.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        /// (optional) id of the link block pointing to this set
        public var blockID: String = String()

        /// id of the new set
        public var targetID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.CreateSet.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// ...
            case unknownObjectTypeURL // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .unknownObjectTypeURL
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .unknownObjectTypeURL: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.CreateSet.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    ///
    /// Remove blocks from the childrenIds of its parents
    public struct Unlink {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context block
        public var contextID: String = String()

        /// targets to remove
        public var blockIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Unlink.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Unlink.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Unlink.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Unlink.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    ///
    /// Block.Close – it means unsubscribe from a block.
    /// Precondition: block should be opened.
    public struct Close {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// id of the context blo1k
        public var contextID: String = String()

        public var blockID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Block.Close.Response.Error {
          get {return _error ?? Anytype_Rpc.Block.Close.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Block.Close.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Block.Close.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct Workspace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct GetCurrent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Workspace.GetCurrent.Response.Error {
          get {return _error ?? Anytype_Rpc.Workspace.GetCurrent.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var workspaceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Workspace.GetCurrent.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Workspace.GetCurrent.Response.Error? = nil
      }

      public init() {}
    }

    public struct GetAll {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Workspace.GetAll.Response.Error {
          get {return _error ?? Anytype_Rpc.Workspace.GetAll.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var workspaceIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Workspace.GetAll.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Workspace.GetAll.Response.Error? = nil
      }

      public init() {}
    }

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Workspace.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.Workspace.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var workspaceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Workspace.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Workspace.Create.Response.Error? = nil
      }

      public init() {}
    }

    public struct SetIsHighlighted {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objectID: String = String()

        public var isHighlighted: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error {
          get {return _error ?? Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error? = nil
      }

      public init() {}
    }

    public struct Select {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var workspaceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Workspace.Select.Response.Error {
          get {return _error ?? Anytype_Rpc.Workspace.Select.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Workspace.Select.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Workspace.Select.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  ///
  /// Namespace, that aggregates subtopics and actions, that relates to wallet.
  public struct Wallet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///*
      /// Front-end-to-middleware request to create a new wallet
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Path to a wallet directory
        public var rootPath: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      ///*
      /// Middleware-to-front-end response, that can contain mnemonic of a created account and a NULL error or an empty mnemonic and a non-NULL error
      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Wallet.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.Wallet.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        /// Mnemonic of a new account (sequence of words, divided by spaces)
        public var mnemonic: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Wallet.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error; mnemonic should be non-empty
            case null // = 0

            /// Any other errors
            case unknownError // = 1

            /// Root path is wrong
            case badInput // = 2

            /// ...
            case failedToCreateLocalRepo // = 101
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .failedToCreateLocalRepo
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .failedToCreateLocalRepo: return 101
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Wallet.Create.Response.Error? = nil
      }

      public init() {}
    }

    public struct Recover {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///*
      /// Front end to middleware request-to-recover-a wallet with this mnemonic and a rootPath
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Path to a wallet directory
        public var rootPath: String = String()

        /// Mnemonic of a wallet to recover
        public var mnemonic: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      ///*
      /// Middleware-to-front-end response, that can contain a NULL error or a non-NULL error
      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Error while trying to recover a wallet
        public var error: Anytype_Rpc.Wallet.Recover.Response.Error {
          get {return _error ?? Anytype_Rpc.Wallet.Recover.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Wallet.Recover.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error; wallet successfully recovered
            case null // = 0

            /// Any other errors
            case unknownError // = 1

            /// Root path or mnemonic is wrong
            case badInput // = 2
            case failedToCreateLocalRepo // = 101
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .failedToCreateLocalRepo
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .failedToCreateLocalRepo: return 101
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Wallet.Recover.Response.Error? = nil
      }

      public init() {}
    }

    public struct Convert {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Mnemonic of a wallet to convert
        public var mnemonic: String = String()

        /// entropy of a wallet to convert
        public var entropy: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Error while trying to recover a wallet
        public var error: Anytype_Rpc.Wallet.Convert.Response.Error {
          get {return _error ?? Anytype_Rpc.Wallet.Convert.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var entropy: String = String()

        public var mnemonic: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Wallet.Convert.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error; wallet successfully recovered
            case null // = 0

            /// Any other errors
            case unknownError // = 1

            /// mnemonic is wrong
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Wallet.Convert.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  ///
  /// Namespace, that agregates subtopics and actions, that relates to account.
  public struct Account {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Config {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var enableDataview: Bool = false

      public var enableDebug: Bool = false

      public var enableReleaseChannelSwitch: Bool = false

      public var enableSpaces: Bool = false

      public var extra: SwiftProtobuf.Google_Protobuf_Struct {
        get {return _extra ?? SwiftProtobuf.Google_Protobuf_Struct()}
        set {_extra = newValue}
      }
      /// Returns true if `extra` has been explicitly set.
      public var hasExtra: Bool {return self._extra != nil}
      /// Clears the value of `extra`. Subsequent reads from it will return its default value.
      public mutating func clearExtra() {self._extra = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _extra: SwiftProtobuf.Google_Protobuf_Struct? = nil
    }

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///*
      /// Front end to middleware request-to-create-an account
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Account name
        public var name: String = String()

        public var avatar: Anytype_Rpc.Account.Create.Request.OneOf_Avatar? = nil

        /// Path to an image, that will be used as an avatar of this account
        public var avatarLocalPath: String {
          get {
            if case .avatarLocalPath(let v)? = avatar {return v}
            return String()
          }
          set {avatar = .avatarLocalPath(newValue)}
        }

        /// Avatar color as an alternative for avatar image
        public var avatarColor: String {
          get {
            if case .avatarColor(let v)? = avatar {return v}
            return String()
          }
          set {avatar = .avatarColor(newValue)}
        }

        public var alphaInviteCode: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Avatar: Equatable {
          /// Path to an image, that will be used as an avatar of this account
          case avatarLocalPath(String)
          /// Avatar color as an alternative for avatar image
          case avatarColor(String)

        #if !swift(>=4.1)
          public static func ==(lhs: Anytype_Rpc.Account.Create.Request.OneOf_Avatar, rhs: Anytype_Rpc.Account.Create.Request.OneOf_Avatar) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.avatarLocalPath, .avatarLocalPath): return {
              guard case .avatarLocalPath(let l) = lhs, case .avatarLocalPath(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.avatarColor, .avatarColor): return {
              guard case .avatarColor(let l) = lhs, case .avatarColor(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            default: return false
            }
          }
        #endif
        }

        public init() {}
      }

      ///*
      /// Middleware-to-front-end response for an account creation request, that can contain a NULL error and created account or a non-NULL error and an empty account
      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Error while trying to create an account
        public var error: Anytype_Rpc.Account.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.Account.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        /// A newly created account; In case of a failure, i.e. error is non-NULL, the account model should contain empty/default-value fields
        public var account: Anytype_Model_Account {
          get {return _account ?? Anytype_Model_Account()}
          set {_account = newValue}
        }
        /// Returns true if `account` has been explicitly set.
        public var hasAccount: Bool {return self._account != nil}
        /// Clears the value of `account`. Subsequent reads from it will return its default value.
        public mutating func clearAccount() {self._account = nil}

        public var config: Anytype_Rpc.Account.Config {
          get {return _config ?? Anytype_Rpc.Account.Config()}
          set {_config = newValue}
        }
        /// Returns true if `config` has been explicitly set.
        public var hasConfig: Bool {return self._config != nil}
        /// Clears the value of `config`. Subsequent reads from it will return its default value.
        public mutating func clearConfig() {self._config = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Account.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error; Account should be non-empty
            case null // = 0

            /// Any other errors
            case unknownError // = 1

            /// Avatar or name is not correct
            case badInput // = 2
            case accountCreatedButFailedToStartNode // = 101
            case accountCreatedButFailedToSetName // = 102
            case accountCreatedButFailedToSetAvatar // = 103
            case failedToStopRunningNode // = 104
            case badInviteCode // = 900
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .accountCreatedButFailedToStartNode
              case 102: self = .accountCreatedButFailedToSetName
              case 103: self = .accountCreatedButFailedToSetAvatar
              case 104: self = .failedToStopRunningNode
              case 900: self = .badInviteCode
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .accountCreatedButFailedToStartNode: return 101
              case .accountCreatedButFailedToSetName: return 102
              case .accountCreatedButFailedToSetAvatar: return 103
              case .failedToStopRunningNode: return 104
              case .badInviteCode: return 900
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Account.Create.Response.Error? = nil
        fileprivate var _account: Anytype_Model_Account? = nil
        fileprivate var _config: Anytype_Rpc.Account.Config? = nil
      }

      public init() {}
    }

    public struct Recover {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///*
      /// Front end to middleware request-to-start-search of an accounts for a recovered mnemonic.
      /// Each of an account that would be found will come with an AccountAdd event
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      ///*
      /// Middleware-to-front-end response to an account recover request, that can contain a NULL error and created account or a non-NULL error and an empty account
      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Error while trying to recover an account
        public var error: Anytype_Rpc.Account.Recover.Response.Error {
          get {return _error ?? Anytype_Rpc.Account.Recover.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Account.Recover.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error;
            case null // = 0

            /// Any other errors
            case unknownError // = 1
            case badInput // = 2
            case noAccountsFound // = 101
            case needToRecoverWalletFirst // = 102
            case failedToCreateLocalRepo // = 103
            case localRepoExistsButCorrupted // = 104
            case failedToRunNode // = 105
            case walletRecoverNotPerformed // = 106
            case failedToStopRunningNode // = 107
            case anotherAnytypeProcessIsRunning // = 108
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .noAccountsFound
              case 102: self = .needToRecoverWalletFirst
              case 103: self = .failedToCreateLocalRepo
              case 104: self = .localRepoExistsButCorrupted
              case 105: self = .failedToRunNode
              case 106: self = .walletRecoverNotPerformed
              case 107: self = .failedToStopRunningNode
              case 108: self = .anotherAnytypeProcessIsRunning
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .noAccountsFound: return 101
              case .needToRecoverWalletFirst: return 102
              case .failedToCreateLocalRepo: return 103
              case .localRepoExistsButCorrupted: return 104
              case .failedToRunNode: return 105
              case .walletRecoverNotPerformed: return 106
              case .failedToStopRunningNode: return 107
              case .anotherAnytypeProcessIsRunning: return 108
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Account.Recover.Response.Error? = nil
      }

      public init() {}
    }

    public struct Select {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///*
      /// Front end to middleware request-to-launch-a specific account using account id and a root path
      /// User can select an account from those, that came with an AccountAdd events
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Id of a selected account
        public var id: String = String()

        /// Root path is optional, set if this is a first request
        public var rootPath: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      ///*
      /// Middleware-to-front-end response for an account select request, that can contain a NULL error and selected account or a non-NULL error and an empty account
      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Error while trying to launch/select an account
        public var error: Anytype_Rpc.Account.Select.Response.Error {
          get {return _error ?? Anytype_Rpc.Account.Select.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        /// Selected account
        public var account: Anytype_Model_Account {
          get {return _account ?? Anytype_Model_Account()}
          set {_account = newValue}
        }
        /// Returns true if `account` has been explicitly set.
        public var hasAccount: Bool {return self._account != nil}
        /// Clears the value of `account`. Subsequent reads from it will return its default value.
        public mutating func clearAccount() {self._account = nil}

        public var config: Anytype_Rpc.Account.Config {
          get {return _config ?? Anytype_Rpc.Account.Config()}
          set {_config = newValue}
        }
        /// Returns true if `config` has been explicitly set.
        public var hasConfig: Bool {return self._config != nil}
        /// Clears the value of `config`. Subsequent reads from it will return its default value.
        public mutating func clearConfig() {self._config = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Account.Select.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error
            case null // = 0

            /// Any other errors
            case unknownError // = 1

            /// Id or root path is wrong
            case badInput // = 2
            case failedToCreateLocalRepo // = 101
            case localRepoExistsButCorrupted // = 102
            case failedToRunNode // = 103
            case failedToFindAccountInfo // = 104
            case localRepoNotExistsAndMnemonicNotSet // = 105
            case failedToStopSearcherNode // = 106
            case failedToRecoverPredefinedBlocks // = 107
            case anotherAnytypeProcessIsRunning // = 108
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .failedToCreateLocalRepo
              case 102: self = .localRepoExistsButCorrupted
              case 103: self = .failedToRunNode
              case 104: self = .failedToFindAccountInfo
              case 105: self = .localRepoNotExistsAndMnemonicNotSet
              case 106: self = .failedToStopSearcherNode
              case 107: self = .failedToRecoverPredefinedBlocks
              case 108: self = .anotherAnytypeProcessIsRunning
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .failedToCreateLocalRepo: return 101
              case .localRepoExistsButCorrupted: return 102
              case .failedToRunNode: return 103
              case .failedToFindAccountInfo: return 104
              case .localRepoNotExistsAndMnemonicNotSet: return 105
              case .failedToStopSearcherNode: return 106
              case .failedToRecoverPredefinedBlocks: return 107
              case .anotherAnytypeProcessIsRunning: return 108
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Account.Select.Response.Error? = nil
        fileprivate var _account: Anytype_Model_Account? = nil
        fileprivate var _config: Anytype_Rpc.Account.Config? = nil
      }

      public init() {}
    }

    public struct Stop {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///*
      /// Front end to middleware request to stop currently running account node and optionally remove the locally stored data
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var removeData: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      ///*
      /// Middleware-to-front-end response for an account stop request
      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Error while trying to launch/select an account
        public var error: Anytype_Rpc.Account.Stop.Response.Error {
          get {return _error ?? Anytype_Rpc.Account.Stop.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Account.Stop.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int

            /// No error
            case null // = 0

            /// Any other errors
            case unknownError // = 1

            /// Id or root path is wrong
            case badInput // = 2
            case accountIsNotRunning // = 101
            case failedToStopNode // = 102
            case failedToRemoveAccountData // = 103
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .accountIsNotRunning
              case 102: self = .failedToStopNode
              case 103: self = .failedToRemoveAccountData
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .accountIsNotRunning: return 101
              case .failedToStopNode: return 102
              case .failedToRemoveAccountData: return 103
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Account.Stop.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  ///
  /// Namespace, that agregates log subtopics and actions.
  /// Usage: send request with topic (Level) and description (message) from client to middleware to log.
  public struct Log {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Send {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var message: String = String()

        public var level: Anytype_Rpc.Log.Send.Request.Level = .debug

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Level: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case debug // = 0
          case error // = 1
          case fatal // = 2
          case info // = 3
          case panic // = 4
          case warning // = 5
          case UNRECOGNIZED(Int)

          public init() {
            self = .debug
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .debug
            case 1: self = .error
            case 2: self = .fatal
            case 3: self = .info
            case 4: self = .panic
            case 5: self = .warning
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .debug: return 0
            case .error: return 1
            case .fatal: return 2
            case .info: return 3
            case .panic: return 4
            case .warning: return 5
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Log.Send.Response.Error {
          get {return _error ?? Anytype_Rpc.Log.Send.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Log.Send.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case notFound // = 101
            case timeout // = 102
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .notFound
              case 102: self = .timeout
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .notFound: return 101
              case .timeout: return 102
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Log.Send.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  ///
  /// Get info about a version of a middleware.
  /// Info is a string, that contains: BuildDate, GitCommit, GitBranch, GitState
  public struct Version {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Get {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Version.Get.Response.Error {
          get {return _error ?? Anytype_Rpc.Version.Get.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var version: String = String()

        /// build date, branch and commit
        public var details: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Version.Get.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case versionIsEmpty // = 3
            case notFound // = 101
            case timeout // = 102
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .versionIsEmpty
              case 101: self = .notFound
              case 102: self = .timeout
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .versionIsEmpty: return 3
              case .notFound: return 101
              case .timeout: return 102
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Version.Get.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct File {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Offload {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var includeNotPinned: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.File.Offload.Response.Error {
          get {return _error ?? Anytype_Rpc.File.Offload.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var bytesOffloaded: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.File.Offload.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// ...
            case nodeNotStarted // = 103
            case fileNotYetPinned // = 104
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 103: self = .nodeNotStarted
              case 104: self = .fileNotYetPinned
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .nodeNotStarted: return 103
              case .fileNotYetPinned: return 104
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.File.Offload.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct FileList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Offload {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// empty means all
        public var onlyIds: [String] = []

        /// false mean not-yet-pinned files will be not
        public var includeNotPinned: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.FileList.Offload.Response.Error {
          get {return _error ?? Anytype_Rpc.FileList.Offload.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var filesOffloaded: Int32 = 0

        public var bytesOffloaded: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.FileList.Offload.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// ...
            case nodeNotStarted // = 103
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 103: self = .nodeNotStarted
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .nodeNotStarted: return 103
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.FileList.Offload.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct Shutdown {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.Shutdown.Response.Error {
        get {return _error ?? Anytype_Rpc.Shutdown.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.Shutdown.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1
          case badInput // = 2
          case nodeNotStarted // = 101
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            case 101: self = .nodeNotStarted
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .nodeNotStarted: return 101
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.Shutdown.Response.Error? = nil
    }

    public init() {}
  }

  public struct Config {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Get {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Config.Get.Response.Error {
          get {return _error ?? Anytype_Rpc.Config.Get.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        /// home dashboard block id
        public var homeBlockID: String = String()

        /// archive block id
        public var archiveBlockID: String = String()

        /// profile block id
        public var profileBlockID: String = String()

        /// marketplace type id
        public var marketplaceTypeID: String = String()

        /// marketplace relation id
        public var marketplaceRelationID: String = String()

        /// marketplace template id
        public var marketplaceTemplateID: String = String()

        /// gateway url for fetching static files
        public var gatewayURL: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Config.Get.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case nodeNotStarted // = 101
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 101: self = .nodeNotStarted
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .nodeNotStarted: return 101
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Config.Get.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct Ping {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var index: Int32 = 0

      public var numberOfEventsToSend: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.Ping.Response.Error {
        get {return _error ?? Anytype_Rpc.Ping.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var index: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.Ping.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.Ping.Response.Error? = nil
    }

    public init() {}
  }

  public struct Process {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Cancel {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Process.Cancel.Response.Error {
          get {return _error ?? Anytype_Rpc.Process.Cancel.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Process.Cancel.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Process.Cancel.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct LinkPreview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var url: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.LinkPreview.Response.Error {
        get {return _error ?? Anytype_Rpc.LinkPreview.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var linkPreview: Anytype_Model_LinkPreview {
        get {return _linkPreview ?? Anytype_Model_LinkPreview()}
        set {_linkPreview = newValue}
      }
      /// Returns true if `linkPreview` has been explicitly set.
      public var hasLinkPreview: Bool {return self._linkPreview != nil}
      /// Clears the value of `linkPreview`. Subsequent reads from it will return its default value.
      public mutating func clearLinkPreview() {self._linkPreview = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.LinkPreview.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.LinkPreview.Response.Error? = nil
      fileprivate var _linkPreview: Anytype_Model_LinkPreview? = nil
    }

    public init() {}
  }

  public struct UploadFile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var url: String = String()

      public var localPath: String = String()

      public var type: Anytype_Model_Block.Content.File.TypeEnum = .none

      public var disableEncryption: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.UploadFile.Response.Error {
        get {return _error ?? Anytype_Rpc.UploadFile.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var hash: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.UploadFile.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.UploadFile.Response.Error? = nil
    }

    public init() {}
  }

  public struct DownloadFile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var hash: String = String()

      /// path to save file. Temp directory is used if empty
      public var path: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.DownloadFile.Response.Error {
        get {return _error ?? Anytype_Rpc.DownloadFile.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var localPath: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.DownloadFile.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1
          case badInput // = 2
          case notFound // = 3
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            case 3: self = .notFound
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .notFound: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.DownloadFile.Response.Error? = nil
    }

    public init() {}
  }

  public struct Navigation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Context: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case navigation // = 0

      /// do not show sets/archive
      case moveTo // = 1

      /// same for mention, do not show sets/archive
      case linkTo // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .navigation
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .navigation
        case 1: self = .moveTo
        case 2: self = .linkTo
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .navigation: return 0
        case .moveTo: return 1
        case .linkTo: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public struct ListObjects {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var context: Anytype_Rpc.Navigation.Context = .navigation

        public var fullText: String = String()

        public var limit: Int32 = 0

        public var offset: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Navigation.ListObjects.Response.Error {
          get {return _error ?? Anytype_Rpc.Navigation.ListObjects.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var objects: [Anytype_Model_ObjectInfo] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Navigation.ListObjects.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Navigation.ListObjects.Response.Error? = nil
      }

      public init() {}
    }

    ///
    /// Get the info for page alongside with info for all inbound and outbound links from/to this page
    public struct GetObjectInfoWithLinks {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objectID: String = String()

        public var context: Anytype_Rpc.Navigation.Context = .navigation

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error {
          get {return _error ?? Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var object: Anytype_Model_ObjectInfoWithLinks {
          get {return _object ?? Anytype_Model_ObjectInfoWithLinks()}
          set {_object = newValue}
        }
        /// Returns true if `object` has been explicitly set.
        public var hasObject: Bool {return self._object != nil}
        /// Clears the value of `object`. Subsequent reads from it will return its default value.
        public mutating func clearObject() {self._object = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error? = nil
        fileprivate var _object: Anytype_Model_ObjectInfoWithLinks? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct History {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// returns list of versions (changes)
    public struct Versions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Version {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var previousIds: [String] = []

        public var authorID: String = String()

        public var authorName: String = String()

        public var time: Int64 = 0

        public var groupID: Int64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var pageID: String = String()

        /// when indicated, results will include versions before given id
        public var lastVersionID: String = String()

        /// desired count of versions
        public var limit: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.History.Versions.Response.Error {
          get {return _error ?? Anytype_Rpc.History.Versions.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var versions: [Anytype_Rpc.History.Versions.Version] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.History.Versions.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.History.Versions.Response.Error? = nil
      }

      public init() {}
    }

    /// returns blockShow event for given version
    public struct Show {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var pageID: String = String()

        public var versionID: String = String()

        public var traceID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.History.Show.Response.Error {
          get {return _storage._error ?? Anytype_Rpc.History.Show.Response.Error()}
          set {_uniqueStorage()._error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return _storage._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {_uniqueStorage()._error = nil}

        public var objectShow: Anytype_Event.Object.Show {
          get {return _storage._objectShow ?? Anytype_Event.Object.Show()}
          set {_uniqueStorage()._objectShow = newValue}
        }
        /// Returns true if `objectShow` has been explicitly set.
        public var hasObjectShow: Bool {return _storage._objectShow != nil}
        /// Clears the value of `objectShow`. Subsequent reads from it will return its default value.
        public mutating func clearObjectShow() {_uniqueStorage()._objectShow = nil}

        public var version: Anytype_Rpc.History.Versions.Version {
          get {return _storage._version ?? Anytype_Rpc.History.Versions.Version()}
          set {_uniqueStorage()._version = newValue}
        }
        /// Returns true if `version` has been explicitly set.
        public var hasVersion: Bool {return _storage._version != nil}
        /// Clears the value of `version`. Subsequent reads from it will return its default value.
        public mutating func clearVersion() {_uniqueStorage()._version = nil}

        public var traceID: String {
          get {return _storage._traceID}
          set {_uniqueStorage()._traceID = newValue}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.History.Show.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      public init() {}
    }

    public struct SetVersion {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var pageID: String = String()

        public var versionID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.History.SetVersion.Response.Error {
          get {return _error ?? Anytype_Rpc.History.SetVersion.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.History.SetVersion.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.History.SetVersion.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct Page {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// page details
        public var details: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_details = newValue}
        }
        /// Returns true if `details` has been explicitly set.
        public var hasDetails: Bool {return self._details != nil}
        /// Clears the value of `details`. Subsequent reads from it will return its default value.
        public mutating func clearDetails() {self._details = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Page.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.Page.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var pageID: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Page.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Page.Create.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var source: [String] = []

        /// if omitted the name of page will be the same with object type
        public var details: SwiftProtobuf.Google_Protobuf_Struct {
          get {return _details ?? SwiftProtobuf.Google_Protobuf_Struct()}
          set {_details = newValue}
        }
        /// Returns true if `details` has been explicitly set.
        public var hasDetails: Bool {return self._details != nil}
        /// Clears the value of `details`. Subsequent reads from it will return its default value.
        public mutating func clearDetails() {self._details = nil}

        /// optional template id for creating from template
        public var templateID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _details: SwiftProtobuf.Google_Protobuf_Struct? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Set.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.Set.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var id: String = String()

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Set.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case unknownObjectTypeURL // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .unknownObjectTypeURL
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .unknownObjectTypeURL: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Set.Create.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct ObjectType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct List {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.ObjectType.List.Response.Error {
          get {return _error ?? Anytype_Rpc.ObjectType.List.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var objectTypes: [Anytype_Model_ObjectType] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.ObjectType.List.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.ObjectType.List.Response.Error? = nil
      }

      public init() {}
    }

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objectType: Anytype_Model_ObjectType {
          get {return _objectType ?? Anytype_Model_ObjectType()}
          set {_objectType = newValue}
        }
        /// Returns true if `objectType` has been explicitly set.
        public var hasObjectType: Bool {return self._objectType != nil}
        /// Clears the value of `objectType`. Subsequent reads from it will return its default value.
        public mutating func clearObjectType() {self._objectType = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _objectType: Anytype_Model_ObjectType? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.ObjectType.Create.Response.Error {
          get {return _error ?? Anytype_Rpc.ObjectType.Create.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var objectType: Anytype_Model_ObjectType {
          get {return _objectType ?? Anytype_Model_ObjectType()}
          set {_objectType = newValue}
        }
        /// Returns true if `objectType` has been explicitly set.
        public var hasObjectType: Bool {return self._objectType != nil}
        /// Clears the value of `objectType`. Subsequent reads from it will return its default value.
        public mutating func clearObjectType() {self._objectType = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.ObjectType.Create.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// ...
            case unknownObjectTypeURL // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .unknownObjectTypeURL
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .unknownObjectTypeURL: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.ObjectType.Create.Response.Error? = nil
        fileprivate var _objectType: Anytype_Model_ObjectType? = nil
      }

      public init() {}
    }

    public struct Relation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Add {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var objectTypeURL: String = String()

          public var relations: [Anytype_Model_Relation] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.ObjectType.Relation.Add.Response.Error {
            get {return _error ?? Anytype_Rpc.ObjectType.Relation.Add.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var relations: [Anytype_Model_Relation] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.ObjectType.Relation.Add.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case unknownObjectTypeURL // = 3

              /// ...
              case readonlyObjectType // = 4
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                case 3: self = .unknownObjectTypeURL
                case 4: self = .readonlyObjectType
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .unknownObjectTypeURL: return 3
                case .readonlyObjectType: return 4
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.ObjectType.Relation.Add.Response.Error? = nil
        }

        public init() {}
      }

      public struct Remove {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var objectTypeURL: String = String()

          public var relationKey: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.ObjectType.Relation.Remove.Response.Error {
            get {return _error ?? Anytype_Rpc.ObjectType.Relation.Remove.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.ObjectType.Relation.Remove.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case unknownObjectTypeURL // = 3

              /// ...
              case readonlyObjectType // = 4
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                case 3: self = .unknownObjectTypeURL
                case 4: self = .readonlyObjectType
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .unknownObjectTypeURL: return 3
                case .readonlyObjectType: return 4
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.ObjectType.Relation.Remove.Response.Error? = nil
        }

        public init() {}
      }

      public struct Update {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var objectTypeURL: String = String()

          public var relation: Anytype_Model_Relation {
            get {return _relation ?? Anytype_Model_Relation()}
            set {_relation = newValue}
          }
          /// Returns true if `relation` has been explicitly set.
          public var hasRelation: Bool {return self._relation != nil}
          /// Clears the value of `relation`. Subsequent reads from it will return its default value.
          public mutating func clearRelation() {self._relation = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _relation: Anytype_Model_Relation? = nil
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.ObjectType.Relation.Update.Response.Error {
            get {return _error ?? Anytype_Rpc.ObjectType.Relation.Update.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.ObjectType.Relation.Update.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2
              case unknownObjectTypeURL // = 3

              /// ...
              case readonlyObjectType // = 4
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                case 3: self = .unknownObjectTypeURL
                case 4: self = .readonlyObjectType
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .unknownObjectTypeURL: return 3
                case .readonlyObjectType: return 4
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.ObjectType.Relation.Update.Response.Error? = nil
        }

        public init() {}
      }

      public struct List {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var objectTypeURL: String = String()

          /// add relations from other object types in the end
          public var appendRelationsFromOtherTypes: Bool = false

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.ObjectType.Relation.List.Response.Error {
            get {return _error ?? Anytype_Rpc.ObjectType.Relation.List.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var relations: [Anytype_Model_Relation] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.ObjectType.Relation.List.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1
              case badInput // = 2

              /// ...
              case unknownObjectTypeURL // = 3
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                case 3: self = .unknownObjectTypeURL
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .unknownObjectTypeURL: return 3
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.ObjectType.Relation.List.Response.Error? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public struct Object {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ShareByLink {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objectID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var link: String = String()

        public var error: Anytype_Rpc.Object.ShareByLink.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.ShareByLink.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.ShareByLink.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.ShareByLink.Response.Error? = nil
      }

      public init() {}
    }

    public struct AddWithObjectId {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objectID: String = String()

        public var payload: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.AddWithObjectId.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.AddWithObjectId.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.AddWithObjectId.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.AddWithObjectId.Response.Error? = nil
      }

      public init() {}
    }

    public struct RelationAdd {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var relation: Anytype_Model_Relation {
          get {return _relation ?? Anytype_Model_Relation()}
          set {_relation = newValue}
        }
        /// Returns true if `relation` has been explicitly set.
        public var hasRelation: Bool {return self._relation != nil}
        /// Clears the value of `relation`. Subsequent reads from it will return its default value.
        public mutating func clearRelation() {self._relation = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _relation: Anytype_Model_Relation? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationAdd.Response.Error {
          get {return _storage._error ?? Anytype_Rpc.Object.RelationAdd.Response.Error()}
          set {_uniqueStorage()._error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return _storage._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {_uniqueStorage()._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _storage._event ?? Anytype_ResponseEvent()}
          set {_uniqueStorage()._event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return _storage._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {_uniqueStorage()._event = nil}

        /// deprecated
        public var relationKey: String {
          get {return _storage._relationKey}
          set {_uniqueStorage()._relationKey = newValue}
        }

        public var relation: Anytype_Model_Relation {
          get {return _storage._relation ?? Anytype_Model_Relation()}
          set {_uniqueStorage()._relation = newValue}
        }
        /// Returns true if `relation` has been explicitly set.
        public var hasRelation: Bool {return _storage._relation != nil}
        /// Clears the value of `relation`. Subsequent reads from it will return its default value.
        public mutating func clearRelation() {_uniqueStorage()._relation = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationAdd.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      public init() {}
    }

    public struct RelationUpdate {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String {
          get {return _storage._contextID}
          set {_uniqueStorage()._contextID = newValue}
        }

        /// key of relation to update
        public var relationKey: String {
          get {return _storage._relationKey}
          set {_uniqueStorage()._relationKey = newValue}
        }

        public var relation: Anytype_Model_Relation {
          get {return _storage._relation ?? Anytype_Model_Relation()}
          set {_uniqueStorage()._relation = newValue}
        }
        /// Returns true if `relation` has been explicitly set.
        public var hasRelation: Bool {return _storage._relation != nil}
        /// Clears the value of `relation`. Subsequent reads from it will return its default value.
        public mutating func clearRelation() {_uniqueStorage()._relation = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationUpdate.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.RelationUpdate.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationUpdate.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.RelationUpdate.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct RelationDelete {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var relationKey: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationDelete.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.RelationDelete.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationDelete.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.RelationDelete.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    /// RelationOptionAdd may return existing option in case dataview already has one with the same text
    public struct RelationOptionAdd {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        /// relation key to add the option
        public var relationKey: String = String()

        /// id of select options will be autogenerated
        public var option: Anytype_Model_Relation.Option {
          get {return _option ?? Anytype_Model_Relation.Option()}
          set {_option = newValue}
        }
        /// Returns true if `option` has been explicitly set.
        public var hasOption: Bool {return self._option != nil}
        /// Clears the value of `option`. Subsequent reads from it will return its default value.
        public mutating func clearOption() {self._option = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _option: Anytype_Model_Relation.Option? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationOptionAdd.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.RelationOptionAdd.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var option: Anytype_Model_Relation.Option {
          get {return _option ?? Anytype_Model_Relation.Option()}
          set {_option = newValue}
        }
        /// Returns true if `option` has been explicitly set.
        public var hasOption: Bool {return self._option != nil}
        /// Clears the value of `option`. Subsequent reads from it will return its default value.
        public mutating func clearOption() {self._option = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationOptionAdd.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.RelationOptionAdd.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
        fileprivate var _option: Anytype_Model_Relation.Option? = nil
      }

      public init() {}
    }

    public struct RelationOptionUpdate {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        /// relation key to add the option
        public var relationKey: String = String()

        /// id of select options will be autogenerated
        public var option: Anytype_Model_Relation.Option {
          get {return _option ?? Anytype_Model_Relation.Option()}
          set {_option = newValue}
        }
        /// Returns true if `option` has been explicitly set.
        public var hasOption: Bool {return self._option != nil}
        /// Clears the value of `option`. Subsequent reads from it will return its default value.
        public mutating func clearOption() {self._option = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _option: Anytype_Model_Relation.Option? = nil
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationOptionUpdate.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.RelationOptionUpdate.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationOptionUpdate.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.RelationOptionUpdate.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct RelationOptionDelete {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        /// relation key to add the option
        public var relationKey: String = String()

        /// id of select options to remove
        public var optionID: String = String()

        /// confirm remove all values in records
        public var confirmRemoveAllValuesInRecords: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationOptionDelete.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.RelationOptionDelete.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationOptionDelete.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1
            case badInput // = 2

            /// need to confirm with confirmRemoveAllValuesInRecords=true
            case someRecordsHasRelationValueWithThisOption // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              case 3: self = .someRecordsHasRelationValueWithThisOption
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .someRecordsHasRelationValueWithThisOption: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.RelationOptionDelete.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct RelationListAvailable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.RelationListAvailable.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.RelationListAvailable.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var relations: [Anytype_Model_Relation] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.RelationListAvailable.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.RelationListAvailable.Response.Error? = nil
      }

      public init() {}
    }

    public struct Search {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var filters: [Anytype_Model_Block.Content.Dataview.Filter] = []

        public var sorts: [Anytype_Model_Block.Content.Dataview.Sort] = []

        public var fullText: String = String()

        public var offset: Int32 = 0

        public var limit: Int32 = 0

        /// additional filter by objectTypes
        public var objectTypeFilter: [String] = []

        /// needed keys in details for return, when empty - will return all
        public var keys: [String] = []

        public var ignoreWorkspace: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.Search.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.Search.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var records: [SwiftProtobuf.Google_Protobuf_Struct] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.Search.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.Search.Response.Error? = nil
      }

      public init() {}
    }

    public struct Graph {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var filters: [Anytype_Model_Block.Content.Dataview.Filter] = []

        public var limit: Int32 = 0

        /// additional filter by objectTypes
        public var objectTypeFilter: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Node {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var type: String = String()

        public var name: String = String()

        public var layout: Int32 = 0

        public var description_p: String = String()

        public var iconImage: String = String()

        public var iconEmoji: String = String()

        public var done: Bool = false

        public var relationFormat: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Edge {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var source: String = String()

        public var target: String = String()

        public var name: String = String()

        public var type: Anytype_Rpc.Object.Graph.Edge.TypeEnum = .link

        public var description_p: String = String()

        public var iconImage: String = String()

        public var iconEmoji: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum TypeEnum: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case link // = 0
          case relation // = 1
          case UNRECOGNIZED(Int)

          public init() {
            self = .link
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .link
            case 1: self = .relation
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .link: return 0
            case .relation: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.Graph.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.Graph.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var nodes: [Anytype_Rpc.Object.Graph.Node] = []

        public var edges: [Anytype_Rpc.Object.Graph.Edge] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.Graph.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.Graph.Response.Error? = nil
      }

      public init() {}
    }

    public struct SetLayout {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var layout: Anytype_Model_ObjectType.Layout = .basic

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.SetLayout.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.SetLayout.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.SetLayout.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.SetLayout.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct SetIsFavorite {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var isFavorite: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.SetIsFavorite.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.SetIsFavorite.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.SetIsFavorite.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.SetIsFavorite.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct SetIsArchived {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var isArchived: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.SetIsArchived.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.SetIsArchived.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.SetIsArchived.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.SetIsArchived.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct FeaturedRelation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Add {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var relations: [String] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error {
            get {return _error ?? Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public struct Remove {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var contextID: String = String()

          public var relations: [String] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error {
            get {return _error ?? Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var event: Anytype_ResponseEvent {
            get {return _event ?? Anytype_ResponseEvent()}
            set {_event = newValue}
          }
          /// Returns true if `event` has been explicitly set.
          public var hasEvent: Bool {return self._event != nil}
          /// Clears the value of `event`. Subsequent reads from it will return its default value.
          public mutating func clearEvent() {self._event = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error? = nil
          fileprivate var _event: Anytype_ResponseEvent? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public struct ToSet {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var contextID: String = String()

        public var source: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Object.ToSet.Response.Error {
          get {return _error ?? Anytype_Rpc.Object.ToSet.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var setID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Object.ToSet.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Object.ToSet.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct ObjectList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Delete {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Deletes the object, keys from the local store and unsubscribe from remote changes. Also offloads all orphan files
      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// objects to remove
        public var objectIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.ObjectList.Delete.Response.Error {
          get {return _error ?? Anytype_Rpc.ObjectList.Delete.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var event: Anytype_ResponseEvent {
          get {return _event ?? Anytype_ResponseEvent()}
          set {_event = newValue}
        }
        /// Returns true if `event` has been explicitly set.
        public var hasEvent: Bool {return self._event != nil}
        /// Clears the value of `event`. Subsequent reads from it will return its default value.
        public mutating func clearEvent() {self._event = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.ObjectList.Delete.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.ObjectList.Delete.Response.Error? = nil
        fileprivate var _event: Anytype_ResponseEvent? = nil
      }

      public init() {}
    }

    public struct Set {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct IsArchived {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var objectIds: [String] = []

          public var isArchived: Bool = false

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error {
            get {return _error ?? Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error? = nil
        }

        public init() {}
      }

      public struct IsFavorite {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Request {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var objectIds: [String] = []

          public var isFavorite: Bool = false

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public struct Response {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var error: Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error {
            get {return _error ?? Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error()}
            set {_error = newValue}
          }
          /// Returns true if `error` has been explicitly set.
          public var hasError: Bool {return self._error != nil}
          /// Clears the value of `error`. Subsequent reads from it will return its default value.
          public mutating func clearError() {self._error = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct Error {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var code: Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error.Code = .null

            public var description_p: String = String()

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Code: SwiftProtobuf.Enum {
              public typealias RawValue = Int
              case null // = 0
              case unknownError // = 1

              /// ...
              case badInput // = 2
              case UNRECOGNIZED(Int)

              public init() {
                self = .null
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .null
                case 1: self = .unknownError
                case 2: self = .badInput
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .null: return 0
                case .unknownError: return 1
                case .badInput: return 2
                case .UNRECOGNIZED(let i): return i
                }
              }

            }

            public init() {}
          }

          public init() {}

          fileprivate var _error: Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error? = nil
        }

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public struct Export {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Format: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case markdown // = 0
      case protobuf // = 1
      case json // = 2
      case dot // = 3
      case svg // = 4
      case graphJson // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .markdown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .markdown
        case 1: self = .protobuf
        case 2: self = .json
        case 3: self = .dot
        case 4: self = .svg
        case 5: self = .graphJson
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .markdown: return 0
        case .protobuf: return 1
        case .json: return 2
        case .dot: return 3
        case .svg: return 4
        case .graphJson: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// the path where export files will place
      public var path: String = String()

      /// ids of documents for export, when empty - will export all available docs
      public var docIds: [String] = []

      /// export format
      public var format: Anytype_Rpc.Export.Format = .markdown

      /// save as zip file
      public var zip: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.Export.Response.Error {
        get {return _error ?? Anytype_Rpc.Export.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var path: String = String()

      public var event: Anytype_ResponseEvent {
        get {return _event ?? Anytype_ResponseEvent()}
        set {_event = newValue}
      }
      /// Returns true if `event` has been explicitly set.
      public var hasEvent: Bool {return self._event != nil}
      /// Clears the value of `event`. Subsequent reads from it will return its default value.
      public mutating func clearEvent() {self._event = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.Export.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.Export.Response.Error? = nil
      fileprivate var _event: Anytype_ResponseEvent? = nil
    }

    public init() {}
  }

  public struct ExportTemplates {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// the path where export files will place
      public var path: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.ExportTemplates.Response.Error {
        get {return _error ?? Anytype_Rpc.ExportTemplates.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var path: String = String()

      public var event: Anytype_ResponseEvent {
        get {return _event ?? Anytype_ResponseEvent()}
        set {_event = newValue}
      }
      /// Returns true if `event` has been explicitly set.
      public var hasEvent: Bool {return self._event != nil}
      /// Clears the value of `event`. Subsequent reads from it will return its default value.
      public mutating func clearEvent() {self._event = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.ExportTemplates.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.ExportTemplates.Response.Error? = nil
      fileprivate var _event: Anytype_ResponseEvent? = nil
    }

    public init() {}
  }

  public struct ExportLocalstore {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// the path where export files will place
      public var path: String = String()

      /// ids of documents for export, when empty - will export all available docs
      public var docIds: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.ExportLocalstore.Response.Error {
        get {return _error ?? Anytype_Rpc.ExportLocalstore.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var path: String = String()

      public var event: Anytype_ResponseEvent {
        get {return _event ?? Anytype_ResponseEvent()}
        set {_event = newValue}
      }
      /// Returns true if `event` has been explicitly set.
      public var hasEvent: Bool {return self._event != nil}
      /// Clears the value of `event`. Subsequent reads from it will return its default value.
      public mutating func clearEvent() {self._event = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.ExportLocalstore.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.ExportLocalstore.Response.Error? = nil
      fileprivate var _event: Anytype_ResponseEvent? = nil
    }

    public init() {}
  }

  public struct MakeTemplate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// id of block for making them template
      public var contextID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.MakeTemplate.Response.Error {
        get {return _error ?? Anytype_Rpc.MakeTemplate.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      /// created template id
      public var id: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.MakeTemplate.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.MakeTemplate.Response.Error? = nil
    }

    public init() {}
  }

  public struct MakeTemplateByObjectType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// id of desired object type
      public var objectType: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.MakeTemplateByObjectType.Response.Error {
        get {return _error ?? Anytype_Rpc.MakeTemplateByObjectType.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      /// created template id
      public var id: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.MakeTemplateByObjectType.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.MakeTemplateByObjectType.Response.Error? = nil
    }

    public init() {}
  }

  public struct CloneTemplate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// id of template block for cloning
      public var contextID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.CloneTemplate.Response.Error {
        get {return _error ?? Anytype_Rpc.CloneTemplate.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      /// created template id
      public var id: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.CloneTemplate.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.CloneTemplate.Response.Error? = nil
    }

    public init() {}
  }

  public struct ApplyTemplate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Request {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var contextID: String = String()

      /// id of template
      public var templateID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Response {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var error: Anytype_Rpc.ApplyTemplate.Response.Error {
        get {return _error ?? Anytype_Rpc.ApplyTemplate.Response.Error()}
        set {_error = newValue}
      }
      /// Returns true if `error` has been explicitly set.
      public var hasError: Bool {return self._error != nil}
      /// Clears the value of `error`. Subsequent reads from it will return its default value.
      public mutating func clearError() {self._error = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Error {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var code: Anytype_Rpc.ApplyTemplate.Response.Error.Code = .null

        public var description_p: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Code: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case null // = 0
          case unknownError // = 1

          /// ...
          case badInput // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .null
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .null
            case 1: self = .unknownError
            case 2: self = .badInput
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .null: return 0
            case .unknownError: return 1
            case .badInput: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public init() {}

      fileprivate var _error: Anytype_Rpc.ApplyTemplate.Response.Error? = nil
    }

    public init() {}
  }

  public struct Debug {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct logInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: String = String()

      public var head: String = String()

      public var headDownloaded: Bool = false

      public var totalRecords: Int32 = 0

      public var totalSize: Int32 = 0

      public var firstRecordTs: Int32 = 0

      public var firstRecordVer: Int32 = 0

      public var lastRecordTs: Int32 = 0

      public var lastRecordVer: Int32 = 0

      public var lastPullSecAgo: Int32 = 0

      public var upStatus: String = String()

      public var downStatus: String = String()

      public var error: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct threadInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: String = String()

      public var logsWithDownloadedHead: Int32 = 0

      public var logsWithWholeTreeDownloaded: Int32 = 0

      public var logs: [Anytype_Rpc.Debug.logInfo] = []

      public var ownLogHasCafeReplicator: Bool = false

      public var cafeLastPullSecAgo: Int32 = 0

      public var cafeUpStatus: String = String()

      public var cafeDownStatus: String = String()

      public var totalRecords: Int32 = 0

      public var totalSize: Int32 = 0

      public var error: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Sync {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// 0 means no limit
        public var recordsTraverseLimit: Int32 = 0

        /// do not set if you want the whole picture
        public var skipEmptyLogs: Bool = false

        /// if try we will try to download remote records in case missing
        public var tryToDownloadRemoteRecords: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Debug.Sync.Response.Error {
          get {return _error ?? Anytype_Rpc.Debug.Sync.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var threads: [Anytype_Rpc.Debug.threadInfo] = []

        public var deviceID: String = String()

        public var totalThreads: Int32 = 0

        public var threadsWithoutReplInOwnLog: Int32 = 0

        public var threadsWithoutHeadDownloaded: Int32 = 0

        public var totalRecords: Int32 = 0

        public var totalSize: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Debug.Sync.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Debug.Sync.Response.Error? = nil
      }

      public init() {}
    }

    public struct Thread {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var threadID: String = String()

        /// do not set if you want the whole picture
        public var skipEmptyLogs: Bool = false

        /// if try we will try to download remote records in case missing
        public var tryToDownloadRemoteRecords: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Debug.Thread.Response.Error {
          get {return _error ?? Anytype_Rpc.Debug.Thread.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var info: Anytype_Rpc.Debug.threadInfo {
          get {return _info ?? Anytype_Rpc.Debug.threadInfo()}
          set {_info = newValue}
        }
        /// Returns true if `info` has been explicitly set.
        public var hasInfo: Bool {return self._info != nil}
        /// Clears the value of `info`. Subsequent reads from it will return its default value.
        public mutating func clearInfo() {self._info = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Debug.Thread.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Debug.Thread.Response.Error? = nil
        fileprivate var _info: Anytype_Rpc.Debug.threadInfo? = nil
      }

      public init() {}
    }

    public struct Tree {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Request {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var blockID: String = String()

        public var path: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Response {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var error: Anytype_Rpc.Debug.Tree.Response.Error {
          get {return _error ?? Anytype_Rpc.Debug.Tree.Response.Error()}
          set {_error = newValue}
        }
        /// Returns true if `error` has been explicitly set.
        public var hasError: Bool {return self._error != nil}
        /// Clears the value of `error`. Subsequent reads from it will return its default value.
        public mutating func clearError() {self._error = nil}

        public var filename: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Error {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var code: Anytype_Rpc.Debug.Tree.Response.Error.Code = .null

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum Code: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case null // = 0
            case unknownError // = 1

            /// ...
            case badInput // = 2
            case UNRECOGNIZED(Int)

            public init() {
              self = .null
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .null
              case 1: self = .unknownError
              case 2: self = .badInput
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .null: return 0
              case .unknownError: return 1
              case .badInput: return 2
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _error: Anytype_Rpc.Debug.Tree.Response.Error? = nil
      }

      public init() {}
    }

    public init() {}
  }

  public struct GenericErrorResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var error: Anytype_Rpc.GenericErrorResponse.Error {
      get {return _error ?? Anytype_Rpc.GenericErrorResponse.Error()}
      set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Error {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var code: Anytype_Rpc.GenericErrorResponse.Error.Code = .null

      public var description_p: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Code: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case null // = 0
        case unknownError // = 1

        /// ...
        case badInput // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .null
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .null
          case 1: self = .unknownError
          case 2: self = .badInput
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .null: return 0
          case .unknownError: return 1
          case .badInput: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}

    fileprivate var _error: Anytype_Rpc.GenericErrorResponse.Error? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Anytype_Rpc.ExternalDrop.Files.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ExternalDrop.Files.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ExternalDrop.Content.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ExternalDrop.Content.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Move.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Move.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.MoveToNewPage.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.MoveToNewPage.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Duplicate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Duplicate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.Text.Style.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.Text.Style.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.Text.Color.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.Text.Color.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.Align.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.Align.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.Fields.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.Fields.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.Set.Div.Style.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.Set.Div.Style.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.BlockList.TurnInto.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.BlockList.TurnInto.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Replace.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Replace.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.UpdateContent.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.UpdateContent.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Split.Request.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Split.Request.Mode] = [
    .bottom,
    .top,
    .inner,
    .title,
  ]
}

extension Anytype_Rpc.Block.Split.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Split.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Merge.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Merge.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Copy.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Copy.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Paste.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Paste.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Cut.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Cut.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.ImportMarkdown.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.ImportMarkdown.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Export.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Export.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Upload.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Upload.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Download.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Download.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Fields.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Fields.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Details.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Details.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Restrictions.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Restrictions.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Latex.Text.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Latex.Text.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Text.Text.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Text.Text.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Text.Color.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Text.Color.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Text.Style.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Text.Style.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Text.Checked.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Text.Checked.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.File.Name.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.File.Name.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Image.Name.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Image.Name.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Image.Width.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Image.Width.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Video.Name.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Video.Name.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Video.Width.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Video.Width.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Relation.SetKey.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Relation.SetKey.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Relation.Add.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Relation.Add.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.ObjectType.Set.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.ObjectType.Set.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
  ]
}

extension Anytype_Rpc.Block.Bookmark.Fetch.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Bookmark.Fetch.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.File.CreateAndUpload.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.File.CreateAndUpload.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .notADataviewBlock,
  ]
}

extension Anytype_Rpc.Block.Dataview.SetSource.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Dataview.SetSource.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Get.Marks.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Get.Marks.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Undo.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Undo.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .canNotMove,
  ]
}

extension Anytype_Rpc.Block.Redo.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Redo.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .canNotMove,
  ]
}

extension Anytype_Rpc.Block.Open.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Open.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .notFound,
    .anytypeNeedsUpgrade,
  ]
}

extension Anytype_Rpc.Block.Show.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Show.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .notFound,
    .anytypeNeedsUpgrade,
  ]
}

extension Anytype_Rpc.Block.GetPublicWebURL.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.GetPublicWebURL.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.SetBreadcrumbs.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.SetBreadcrumbs.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.CreatePage.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.CreatePage.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.CreateSet.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.CreateSet.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
  ]
}

extension Anytype_Rpc.Block.Unlink.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Unlink.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Block.Close.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Block.Close.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Workspace.GetCurrent.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Workspace.GetCurrent.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Workspace.GetAll.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Workspace.GetAll.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Workspace.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Workspace.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Workspace.Select.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Workspace.Select.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Wallet.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Wallet.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .failedToCreateLocalRepo,
  ]
}

extension Anytype_Rpc.Wallet.Recover.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Wallet.Recover.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .failedToCreateLocalRepo,
  ]
}

extension Anytype_Rpc.Wallet.Convert.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Wallet.Convert.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Account.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Account.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .accountCreatedButFailedToStartNode,
    .accountCreatedButFailedToSetName,
    .accountCreatedButFailedToSetAvatar,
    .failedToStopRunningNode,
    .badInviteCode,
  ]
}

extension Anytype_Rpc.Account.Recover.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Account.Recover.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .noAccountsFound,
    .needToRecoverWalletFirst,
    .failedToCreateLocalRepo,
    .localRepoExistsButCorrupted,
    .failedToRunNode,
    .walletRecoverNotPerformed,
    .failedToStopRunningNode,
    .anotherAnytypeProcessIsRunning,
  ]
}

extension Anytype_Rpc.Account.Select.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Account.Select.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .failedToCreateLocalRepo,
    .localRepoExistsButCorrupted,
    .failedToRunNode,
    .failedToFindAccountInfo,
    .localRepoNotExistsAndMnemonicNotSet,
    .failedToStopSearcherNode,
    .failedToRecoverPredefinedBlocks,
    .anotherAnytypeProcessIsRunning,
  ]
}

extension Anytype_Rpc.Account.Stop.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Account.Stop.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .accountIsNotRunning,
    .failedToStopNode,
    .failedToRemoveAccountData,
  ]
}

extension Anytype_Rpc.Log.Send.Request.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Log.Send.Request.Level] = [
    .debug,
    .error,
    .fatal,
    .info,
    .panic,
    .warning,
  ]
}

extension Anytype_Rpc.Log.Send.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Log.Send.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .notFound,
    .timeout,
  ]
}

extension Anytype_Rpc.Version.Get.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Version.Get.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .versionIsEmpty,
    .notFound,
    .timeout,
  ]
}

extension Anytype_Rpc.File.Offload.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.File.Offload.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .nodeNotStarted,
    .fileNotYetPinned,
  ]
}

extension Anytype_Rpc.FileList.Offload.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.FileList.Offload.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .nodeNotStarted,
  ]
}

extension Anytype_Rpc.Shutdown.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Shutdown.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .nodeNotStarted,
  ]
}

extension Anytype_Rpc.Config.Get.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Config.Get.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .nodeNotStarted,
  ]
}

extension Anytype_Rpc.Ping.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Ping.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Process.Cancel.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Process.Cancel.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.LinkPreview.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.LinkPreview.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.UploadFile.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.UploadFile.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.DownloadFile.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.DownloadFile.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .notFound,
  ]
}

extension Anytype_Rpc.Navigation.Context: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Navigation.Context] = [
    .navigation,
    .moveTo,
    .linkTo,
  ]
}

extension Anytype_Rpc.Navigation.ListObjects.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Navigation.ListObjects.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.History.Versions.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.History.Versions.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.History.Show.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.History.Show.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.History.SetVersion.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.History.SetVersion.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Page.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Page.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Set.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Set.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
  ]
}

extension Anytype_Rpc.ObjectType.List.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectType.List.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ObjectType.Create.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectType.Create.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
  ]
}

extension Anytype_Rpc.ObjectType.Relation.Add.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectType.Relation.Add.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
    .readonlyObjectType,
  ]
}

extension Anytype_Rpc.ObjectType.Relation.Remove.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectType.Relation.Remove.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
    .readonlyObjectType,
  ]
}

extension Anytype_Rpc.ObjectType.Relation.Update.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectType.Relation.Update.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
    .readonlyObjectType,
  ]
}

extension Anytype_Rpc.ObjectType.Relation.List.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectType.Relation.List.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .unknownObjectTypeURL,
  ]
}

extension Anytype_Rpc.Object.ShareByLink.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.ShareByLink.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.AddWithObjectId.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.AddWithObjectId.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.RelationAdd.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationAdd.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.RelationUpdate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationUpdate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.RelationDelete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationDelete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.RelationOptionAdd.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationOptionAdd.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.RelationOptionUpdate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationOptionUpdate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.RelationOptionDelete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationOptionDelete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
    .someRecordsHasRelationValueWithThisOption,
  ]
}

extension Anytype_Rpc.Object.RelationListAvailable.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.RelationListAvailable.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.Search.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.Search.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.Graph.Edge.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.Graph.Edge.TypeEnum] = [
    .link,
    .relation,
  ]
}

extension Anytype_Rpc.Object.Graph.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.Graph.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.SetLayout.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.SetLayout.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.SetIsFavorite.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.SetIsFavorite.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.SetIsArchived.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.SetIsArchived.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Object.ToSet.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Object.ToSet.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ObjectList.Delete.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectList.Delete.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Export.Format: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Export.Format] = [
    .markdown,
    .protobuf,
    .json,
    .dot,
    .svg,
    .graphJson,
  ]
}

extension Anytype_Rpc.Export.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Export.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ExportTemplates.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ExportTemplates.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ExportLocalstore.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ExportLocalstore.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.MakeTemplate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.MakeTemplate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.MakeTemplateByObjectType.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.MakeTemplateByObjectType.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.CloneTemplate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.CloneTemplate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.ApplyTemplate.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.ApplyTemplate.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Debug.Sync.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Debug.Sync.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Debug.Thread.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Debug.Thread.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.Debug.Tree.Response.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.Debug.Tree.Response.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

extension Anytype_Rpc.GenericErrorResponse.Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Rpc.GenericErrorResponse.Error.Code] = [
    .null,
    .unknownError,
    .badInput,
  ]
}

#endif  // swift(>=4.2)

public struct Anytype_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype"

extension Anytype_Rpc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rpc"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc, rhs: Anytype_Rpc) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".ExternalDrop"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop, rhs: Anytype_Rpc.ExternalDrop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Files: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.protoMessageName + ".Files"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Files, rhs: Anytype_Rpc.ExternalDrop.Files) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Files.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.Files.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "dropTargetId"),
    3: .same(proto: "position"),
    4: .same(proto: "localFilePaths"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dropTargetID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.localFilePaths) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.dropTargetID.isEmpty {
      try visitor.visitSingularStringField(value: self.dropTargetID, fieldNumber: 2)
    }
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 3)
    }
    if !self.localFilePaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.localFilePaths, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Files.Request, rhs: Anytype_Rpc.ExternalDrop.Files.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.dropTargetID != rhs.dropTargetID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.localFilePaths != rhs.localFilePaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Files.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.Files.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Files.Response, rhs: Anytype_Rpc.ExternalDrop.Files.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Files.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.Files.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Files.Response.Error, rhs: Anytype_Rpc.ExternalDrop.Files.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Files.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ExternalDrop.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.protoMessageName + ".Content"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Content, rhs: Anytype_Rpc.ExternalDrop.Content) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Content.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.Content.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "focusedBlockId"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.focusedBlockID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.focusedBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.focusedBlockID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Content.Request, rhs: Anytype_Rpc.ExternalDrop.Content.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.focusedBlockID != rhs.focusedBlockID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Content.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.Content.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Content.Response, rhs: Anytype_Rpc.ExternalDrop.Content.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Content.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExternalDrop.Content.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExternalDrop.Content.Response.Error, rhs: Anytype_Rpc.ExternalDrop.Content.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExternalDrop.Content.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".BlockList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList, rhs: Anytype_Rpc.BlockList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.protoMessageName + ".ConvertChildrenToPages"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.ConvertChildrenToPages, rhs: Anytype_Rpc.BlockList.ConvertChildrenToPages) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.ConvertChildrenToPages.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "objectType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.objectType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if !self.objectType.isEmpty {
      try visitor.visitSingularStringField(value: self.objectType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.ConvertChildrenToPages.Request, rhs: Anytype_Rpc.BlockList.ConvertChildrenToPages.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.objectType != rhs.objectType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.ConvertChildrenToPages.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "linkIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.linkIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.linkIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.linkIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response, rhs: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.linkIds != rhs.linkIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error, rhs: Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.ConvertChildrenToPages.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.protoMessageName + ".Move"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Move, rhs: Anytype_Rpc.BlockList.Move) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Move.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Move.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "targetContextId"),
    4: .same(proto: "dropTargetId"),
    5: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetContextID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dropTargetID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if !self.targetContextID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetContextID, fieldNumber: 3)
    }
    if !self.dropTargetID.isEmpty {
      try visitor.visitSingularStringField(value: self.dropTargetID, fieldNumber: 4)
    }
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Move.Request, rhs: Anytype_Rpc.BlockList.Move.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.targetContextID != rhs.targetContextID {return false}
    if lhs.dropTargetID != rhs.dropTargetID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Move.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Move.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Move.Response, rhs: Anytype_Rpc.BlockList.Move.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Move.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Move.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Move.Response.Error, rhs: Anytype_Rpc.BlockList.Move.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Move.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.MoveToNewPage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.protoMessageName + ".MoveToNewPage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.MoveToNewPage, rhs: Anytype_Rpc.BlockList.MoveToNewPage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.MoveToNewPage.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.MoveToNewPage.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "details"),
    4: .same(proto: "dropTargetId"),
    5: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dropTargetID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.dropTargetID.isEmpty {
      try visitor.visitSingularStringField(value: self.dropTargetID, fieldNumber: 4)
    }
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.MoveToNewPage.Request, rhs: Anytype_Rpc.BlockList.MoveToNewPage.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs._details != rhs._details {return false}
    if lhs.dropTargetID != rhs.dropTargetID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.MoveToNewPage.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.MoveToNewPage.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "linkId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.linkID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.linkID.isEmpty {
      try visitor.visitSingularStringField(value: self.linkID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.MoveToNewPage.Response, rhs: Anytype_Rpc.BlockList.MoveToNewPage.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.linkID != rhs.linkID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.MoveToNewPage.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.MoveToNewPage.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.MoveToNewPage.Response.Error, rhs: Anytype_Rpc.BlockList.MoveToNewPage.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.MoveToNewPage.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Duplicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.protoMessageName + ".Duplicate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Duplicate, rhs: Anytype_Rpc.BlockList.Duplicate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Duplicate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Duplicate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "targetId"),
    3: .same(proto: "blockIds"),
    4: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 3)
    }
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Duplicate.Request, rhs: Anytype_Rpc.BlockList.Duplicate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Duplicate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Duplicate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Duplicate.Response, rhs: Anytype_Rpc.BlockList.Duplicate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Duplicate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Duplicate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Duplicate.Response.Error, rhs: Anytype_Rpc.BlockList.Duplicate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Duplicate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.protoMessageName + ".Set"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set, rhs: Anytype_Rpc.BlockList.Set) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.protoMessageName + ".Text"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text, rhs: Anytype_Rpc.BlockList.Set.Text) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Style, rhs: Anytype_Rpc.BlockList.Set.Text.Style) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Style.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if self.style != .paragraph {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Style.Request, rhs: Anytype_Rpc.BlockList.Set.Text.Style.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Style.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Style.Response, rhs: Anytype_Rpc.BlockList.Set.Text.Style.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Style.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Style.Response.Error, rhs: Anytype_Rpc.BlockList.Set.Text.Style.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Style.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set.Text.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.protoMessageName + ".Color"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Color, rhs: Anytype_Rpc.BlockList.Set.Text.Color) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Color.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Color.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Color.Request, rhs: Anytype_Rpc.BlockList.Set.Text.Color.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Color.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Color.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Color.Response, rhs: Anytype_Rpc.BlockList.Set.Text.Color.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Color.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Color.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Color.Response.Error, rhs: Anytype_Rpc.BlockList.Set.Text.Color.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Color.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set.Text.Mark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.protoMessageName + ".Mark"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Mark, rhs: Anytype_Rpc.BlockList.Set.Text.Mark) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Mark.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Mark.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "mark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    try { if let v = self._mark {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Mark.Request, rhs: Anytype_Rpc.BlockList.Set.Text.Mark.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs._mark != rhs._mark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Mark.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Mark.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Mark.Response, rhs: Anytype_Rpc.BlockList.Set.Text.Mark.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Text.Mark.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error, rhs: Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Text.Mark.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.protoMessageName + ".BackgroundColor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.BackgroundColor, rhs: Anytype_Rpc.BlockList.Set.BackgroundColor) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.BackgroundColor.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.BackgroundColor.Request, rhs: Anytype_Rpc.BlockList.Set.BackgroundColor.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.BackgroundColor.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.BackgroundColor.Response, rhs: Anytype_Rpc.BlockList.Set.BackgroundColor.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.BackgroundColor.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error, rhs: Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.BackgroundColor.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set.Align: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.protoMessageName + ".Align"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Align, rhs: Anytype_Rpc.BlockList.Set.Align) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Align.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Align.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "align"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if self.align != .left {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Align.Request, rhs: Anytype_Rpc.BlockList.Set.Align.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.align != rhs.align {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Align.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Align.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Align.Response, rhs: Anytype_Rpc.BlockList.Set.Align.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Align.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Align.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Align.Response.Error, rhs: Anytype_Rpc.BlockList.Set.Align.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Align.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set.Fields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.protoMessageName + ".Fields"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Fields, rhs: Anytype_Rpc.BlockList.Set.Fields) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Fields.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Fields.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockFields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blockFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockFields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Fields.Request, rhs: Anytype_Rpc.BlockList.Set.Fields.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockFields != rhs.blockFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Fields.Request.BlockField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Fields.Request.protoMessageName + ".BlockField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockId"),
    2: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 1)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Fields.Request.BlockField, rhs: Anytype_Rpc.BlockList.Set.Fields.Request.BlockField) -> Bool {
    if lhs.blockID != rhs.blockID {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Fields.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Fields.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Fields.Response, rhs: Anytype_Rpc.BlockList.Set.Fields.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Fields.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Fields.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Fields.Response.Error, rhs: Anytype_Rpc.BlockList.Set.Fields.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Fields.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.Set.Div: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.protoMessageName + ".Div"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Div, rhs: Anytype_Rpc.BlockList.Set.Div) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Div.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Div.Style, rhs: Anytype_Rpc.BlockList.Set.Div.Style) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Div.Style.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if self.style != .line {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Div.Style.Request, rhs: Anytype_Rpc.BlockList.Set.Div.Style.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Div.Style.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Div.Style.Response, rhs: Anytype_Rpc.BlockList.Set.Div.Style.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.Set.Div.Style.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.Set.Div.Style.Response.Error, rhs: Anytype_Rpc.BlockList.Set.Div.Style.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.Set.Div.Style.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.BlockList.TurnInto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.protoMessageName + ".TurnInto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.TurnInto, rhs: Anytype_Rpc.BlockList.TurnInto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.TurnInto.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.TurnInto.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if self.style != .paragraph {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.TurnInto.Request, rhs: Anytype_Rpc.BlockList.TurnInto.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.TurnInto.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.TurnInto.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.TurnInto.Response, rhs: Anytype_Rpc.BlockList.TurnInto.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.TurnInto.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.BlockList.TurnInto.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.BlockList.TurnInto.Response.Error, rhs: Anytype_Rpc.BlockList.TurnInto.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.BlockList.TurnInto.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Block"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block, rhs: Anytype_Rpc.Block) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Replace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Replace"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Replace, rhs: Anytype_Rpc.Block.Replace) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Replace.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Replace.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Replace.Request, rhs: Anytype_Rpc.Block.Replace.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Replace.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Replace.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Replace.Response, rhs: Anytype_Rpc.Block.Replace.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Replace.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Replace.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Replace.Response.Error, rhs: Anytype_Rpc.Block.Replace.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Replace.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.UpdateContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".UpdateContent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.UpdateContent, rhs: Anytype_Rpc.Block.UpdateContent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.UpdateContent.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.UpdateContent.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.UpdateContent.Request, rhs: Anytype_Rpc.Block.UpdateContent.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.UpdateContent.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.UpdateContent.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.UpdateContent.Response, rhs: Anytype_Rpc.Block.UpdateContent.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.UpdateContent.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.UpdateContent.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.UpdateContent.Response.Error, rhs: Anytype_Rpc.Block.UpdateContent.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.UpdateContent.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Split"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Split, rhs: Anytype_Rpc.Block.Split) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Split.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Split.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "range"),
    4: .same(proto: "style"),
    5: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.style != .paragraph {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 4)
    }
    if self.mode != .bottom {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Split.Request, rhs: Anytype_Rpc.Block.Split.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._range != rhs._range {return false}
    if lhs.style != rhs.style {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Split.Request.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOTTOM"),
    1: .same(proto: "TOP"),
    2: .same(proto: "INNER"),
    3: .same(proto: "TITLE"),
  ]
}

extension Anytype_Rpc.Block.Split.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Split.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Split.Response, rhs: Anytype_Rpc.Block.Split.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Split.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Split.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Split.Response.Error, rhs: Anytype_Rpc.Block.Split.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Split.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Merge"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Merge, rhs: Anytype_Rpc.Block.Merge) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Merge.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Merge.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "firstBlockId"),
    3: .same(proto: "secondBlockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firstBlockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.secondBlockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.firstBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstBlockID, fieldNumber: 2)
    }
    if !self.secondBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.secondBlockID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Merge.Request, rhs: Anytype_Rpc.Block.Merge.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.firstBlockID != rhs.firstBlockID {return false}
    if lhs.secondBlockID != rhs.secondBlockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Merge.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Merge.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Merge.Response, rhs: Anytype_Rpc.Block.Merge.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Merge.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Merge.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Merge.Response.Error, rhs: Anytype_Rpc.Block.Merge.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Merge.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Copy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Copy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Copy, rhs: Anytype_Rpc.Block.Copy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Copy.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Copy.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blocks"),
    3: .same(proto: "selectedTextRange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selectedTextRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    try { if let v = self._selectedTextRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Copy.Request, rhs: Anytype_Rpc.Block.Copy.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs._selectedTextRange != rhs._selectedTextRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Copy.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Copy.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "textSlot"),
    3: .same(proto: "htmlSlot"),
    4: .same(proto: "anySlot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.textSlot) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.htmlSlot) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.anySlot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.textSlot.isEmpty {
      try visitor.visitSingularStringField(value: self.textSlot, fieldNumber: 2)
    }
    if !self.htmlSlot.isEmpty {
      try visitor.visitSingularStringField(value: self.htmlSlot, fieldNumber: 3)
    }
    if !self.anySlot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.anySlot, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Copy.Response, rhs: Anytype_Rpc.Block.Copy.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.textSlot != rhs.textSlot {return false}
    if lhs.htmlSlot != rhs.htmlSlot {return false}
    if lhs.anySlot != rhs.anySlot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Copy.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Copy.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Copy.Response.Error, rhs: Anytype_Rpc.Block.Copy.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Copy.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Paste: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Paste"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Paste, rhs: Anytype_Rpc.Block.Paste) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Paste.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Paste.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "focusedBlockId"),
    3: .same(proto: "selectedTextRange"),
    4: .same(proto: "selectedBlockIds"),
    5: .same(proto: "isPartOfBlock"),
    6: .same(proto: "textSlot"),
    7: .same(proto: "htmlSlot"),
    8: .same(proto: "anySlot"),
    9: .same(proto: "fileSlot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.focusedBlockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selectedTextRange) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.selectedBlockIds) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isPartOfBlock) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.textSlot) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.htmlSlot) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.anySlot) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.fileSlot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.focusedBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.focusedBlockID, fieldNumber: 2)
    }
    try { if let v = self._selectedTextRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.selectedBlockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.selectedBlockIds, fieldNumber: 4)
    }
    if self.isPartOfBlock != false {
      try visitor.visitSingularBoolField(value: self.isPartOfBlock, fieldNumber: 5)
    }
    if !self.textSlot.isEmpty {
      try visitor.visitSingularStringField(value: self.textSlot, fieldNumber: 6)
    }
    if !self.htmlSlot.isEmpty {
      try visitor.visitSingularStringField(value: self.htmlSlot, fieldNumber: 7)
    }
    if !self.anySlot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.anySlot, fieldNumber: 8)
    }
    if !self.fileSlot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSlot, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Paste.Request, rhs: Anytype_Rpc.Block.Paste.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.focusedBlockID != rhs.focusedBlockID {return false}
    if lhs._selectedTextRange != rhs._selectedTextRange {return false}
    if lhs.selectedBlockIds != rhs.selectedBlockIds {return false}
    if lhs.isPartOfBlock != rhs.isPartOfBlock {return false}
    if lhs.textSlot != rhs.textSlot {return false}
    if lhs.htmlSlot != rhs.htmlSlot {return false}
    if lhs.anySlot != rhs.anySlot {return false}
    if lhs.fileSlot != rhs.fileSlot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Paste.Request.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Paste.Request.protoMessageName + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "data"),
    3: .same(proto: "localPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.localPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.localPath.isEmpty {
      try visitor.visitSingularStringField(value: self.localPath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Paste.Request.File, rhs: Anytype_Rpc.Block.Paste.Request.File) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.data != rhs.data {return false}
    if lhs.localPath != rhs.localPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Paste.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Paste.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockIds"),
    3: .same(proto: "caretPosition"),
    4: .same(proto: "isSameBlockCaret"),
    5: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.caretPosition) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSameBlockCaret) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    if self.caretPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.caretPosition, fieldNumber: 3)
    }
    if self.isSameBlockCaret != false {
      try visitor.visitSingularBoolField(value: self.isSameBlockCaret, fieldNumber: 4)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Paste.Response, rhs: Anytype_Rpc.Block.Paste.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.caretPosition != rhs.caretPosition {return false}
    if lhs.isSameBlockCaret != rhs.isSameBlockCaret {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Paste.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Paste.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Paste.Response.Error, rhs: Anytype_Rpc.Block.Paste.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Paste.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Cut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Cut"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Cut, rhs: Anytype_Rpc.Block.Cut) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Cut.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Cut.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blocks"),
    3: .same(proto: "selectedTextRange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selectedTextRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    try { if let v = self._selectedTextRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Cut.Request, rhs: Anytype_Rpc.Block.Cut.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs._selectedTextRange != rhs._selectedTextRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Cut.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Cut.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "textSlot"),
    3: .same(proto: "htmlSlot"),
    4: .same(proto: "anySlot"),
    5: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.textSlot) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.htmlSlot) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.anySlot) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.textSlot.isEmpty {
      try visitor.visitSingularStringField(value: self.textSlot, fieldNumber: 2)
    }
    if !self.htmlSlot.isEmpty {
      try visitor.visitSingularStringField(value: self.htmlSlot, fieldNumber: 3)
    }
    if !self.anySlot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.anySlot, fieldNumber: 4)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Cut.Response, rhs: Anytype_Rpc.Block.Cut.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.textSlot != rhs.textSlot {return false}
    if lhs.htmlSlot != rhs.htmlSlot {return false}
    if lhs.anySlot != rhs.anySlot {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Cut.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Cut.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Cut.Response.Error, rhs: Anytype_Rpc.Block.Cut.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Cut.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.ImportMarkdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".ImportMarkdown"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ImportMarkdown, rhs: Anytype_Rpc.Block.ImportMarkdown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ImportMarkdown.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ImportMarkdown.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "importPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.importPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.importPath.isEmpty {
      try visitor.visitSingularStringField(value: self.importPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ImportMarkdown.Request, rhs: Anytype_Rpc.Block.ImportMarkdown.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.importPath != rhs.importPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ImportMarkdown.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ImportMarkdown.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "rootLinkIds"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.rootLinkIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rootLinkIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rootLinkIds, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ImportMarkdown.Response, rhs: Anytype_Rpc.Block.ImportMarkdown.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.rootLinkIds != rhs.rootLinkIds {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ImportMarkdown.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ImportMarkdown.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ImportMarkdown.Response.Error, rhs: Anytype_Rpc.Block.ImportMarkdown.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ImportMarkdown.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Export: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Export"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Export, rhs: Anytype_Rpc.Block.Export) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Export.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Export.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Export.Request, rhs: Anytype_Rpc.Block.Export.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Export.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Export.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "path"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Export.Response, rhs: Anytype_Rpc.Block.Export.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.path != rhs.path {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Export.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Export.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Export.Response.Error, rhs: Anytype_Rpc.Block.Export.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Export.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Upload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Upload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Upload, rhs: Anytype_Rpc.Block.Upload) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Upload.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Upload.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "filePath"),
    4: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Upload.Request, rhs: Anytype_Rpc.Block.Upload.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Upload.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Upload.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Upload.Response, rhs: Anytype_Rpc.Block.Upload.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Upload.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Upload.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Upload.Response.Error, rhs: Anytype_Rpc.Block.Upload.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Upload.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Download: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Download"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Download, rhs: Anytype_Rpc.Block.Download) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Download.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Download.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Download.Request, rhs: Anytype_Rpc.Block.Download.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Download.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Download.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Download.Response, rhs: Anytype_Rpc.Block.Download.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Download.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Download.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Download.Response.Error, rhs: Anytype_Rpc.Block.Download.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Download.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Set"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set, rhs: Anytype_Rpc.Block.Set) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Fields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Fields"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Fields, rhs: Anytype_Rpc.Block.Set.Fields) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Fields.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Fields.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Fields.Request, rhs: Anytype_Rpc.Block.Set.Fields.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Fields.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Fields.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Fields.Response, rhs: Anytype_Rpc.Block.Set.Fields.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Fields.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Fields.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Fields.Response.Error, rhs: Anytype_Rpc.Block.Set.Fields.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Fields.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Details: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Details"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Details, rhs: Anytype_Rpc.Block.Set.Details) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Details.Detail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Details.protoMessageName + ".Detail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Details.Detail, rhs: Anytype_Rpc.Block.Set.Details.Detail) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Details.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Details.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Details.Request, rhs: Anytype_Rpc.Block.Set.Details.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Details.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Details.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Details.Response, rhs: Anytype_Rpc.Block.Set.Details.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Details.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Details.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Details.Response.Error, rhs: Anytype_Rpc.Block.Set.Details.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Details.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Restrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Restrictions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Restrictions, rhs: Anytype_Rpc.Block.Set.Restrictions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Restrictions.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Restrictions.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "restrictions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._restrictions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._restrictions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Restrictions.Request, rhs: Anytype_Rpc.Block.Set.Restrictions.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._restrictions != rhs._restrictions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Restrictions.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Restrictions.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Restrictions.Response, rhs: Anytype_Rpc.Block.Set.Restrictions.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Restrictions.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Restrictions.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Restrictions.Response.Error, rhs: Anytype_Rpc.Block.Set.Restrictions.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Restrictions.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Page"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Page, rhs: Anytype_Rpc.Block.Set.Page) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Page.protoMessageName + ".IsArchived"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Page.IsArchived, rhs: Anytype_Rpc.Block.Set.Page.IsArchived) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Page.IsArchived.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "isArchived"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Page.IsArchived.Request, rhs: Anytype_Rpc.Block.Set.Page.IsArchived.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Page.IsArchived.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Page.IsArchived.Response, rhs: Anytype_Rpc.Block.Set.Page.IsArchived.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Page.IsArchived.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error, rhs: Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Page.IsArchived.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Latex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Latex"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Latex, rhs: Anytype_Rpc.Block.Set.Latex) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Latex.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Latex.protoMessageName + ".Text"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Latex.Text, rhs: Anytype_Rpc.Block.Set.Latex.Text) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Latex.Text.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Latex.Text.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Latex.Text.Request, rhs: Anytype_Rpc.Block.Set.Latex.Text.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Latex.Text.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Latex.Text.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Latex.Text.Response, rhs: Anytype_Rpc.Block.Set.Latex.Text.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Latex.Text.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Latex.Text.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Latex.Text.Response.Error, rhs: Anytype_Rpc.Block.Set.Latex.Text.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Latex.Text.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Text"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text, rhs: Anytype_Rpc.Block.Set.Text) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.protoMessageName + ".Text"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Text, rhs: Anytype_Rpc.Block.Set.Text.Text) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Text.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Text.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "text"),
    4: .same(proto: "marks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._marks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    try { if let v = self._marks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Text.Request, rhs: Anytype_Rpc.Block.Set.Text.Text.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.text != rhs.text {return false}
    if lhs._marks != rhs._marks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Text.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Text.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Text.Response, rhs: Anytype_Rpc.Block.Set.Text.Text.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Text.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Text.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Text.Response.Error, rhs: Anytype_Rpc.Block.Set.Text.Text.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Text.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Text.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.protoMessageName + ".Color"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Color, rhs: Anytype_Rpc.Block.Set.Text.Color) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Color.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Color.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Color.Request, rhs: Anytype_Rpc.Block.Set.Text.Color.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Color.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Color.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Color.Response, rhs: Anytype_Rpc.Block.Set.Text.Color.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Color.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Color.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Color.Response.Error, rhs: Anytype_Rpc.Block.Set.Text.Color.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Color.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Text.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.protoMessageName + ".Style"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Style, rhs: Anytype_Rpc.Block.Set.Text.Style) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Style.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Style.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if self.style != .paragraph {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Style.Request, rhs: Anytype_Rpc.Block.Set.Text.Style.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Style.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Style.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Style.Response, rhs: Anytype_Rpc.Block.Set.Text.Style.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Style.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Style.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Style.Response.Error, rhs: Anytype_Rpc.Block.Set.Text.Style.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Style.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Text.Checked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.protoMessageName + ".Checked"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Checked, rhs: Anytype_Rpc.Block.Set.Text.Checked) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Checked.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Checked.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "checked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.checked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if self.checked != false {
      try visitor.visitSingularBoolField(value: self.checked, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Checked.Request, rhs: Anytype_Rpc.Block.Set.Text.Checked.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.checked != rhs.checked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Checked.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Checked.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Checked.Response, rhs: Anytype_Rpc.Block.Set.Text.Checked.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Checked.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Text.Checked.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Text.Checked.Response.Error, rhs: Anytype_Rpc.Block.Set.Text.Checked.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Text.Checked.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".File"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.File, rhs: Anytype_Rpc.Block.Set.File) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.File.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.File.protoMessageName + ".Name"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.File.Name, rhs: Anytype_Rpc.Block.Set.File.Name) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.File.Name.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.File.Name.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.File.Name.Request, rhs: Anytype_Rpc.Block.Set.File.Name.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.File.Name.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.File.Name.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.File.Name.Response, rhs: Anytype_Rpc.Block.Set.File.Name.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.File.Name.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.File.Name.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.File.Name.Response.Error, rhs: Anytype_Rpc.Block.Set.File.Name.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.File.Name.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Image"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image, rhs: Anytype_Rpc.Block.Set.Image) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.protoMessageName + ".Name"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Name, rhs: Anytype_Rpc.Block.Set.Image.Name) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Name.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.Name.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Name.Request, rhs: Anytype_Rpc.Block.Set.Image.Name.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Name.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.Name.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Name.Response, rhs: Anytype_Rpc.Block.Set.Image.Name.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Name.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.Name.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Name.Response.Error, rhs: Anytype_Rpc.Block.Set.Image.Name.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Name.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Image.Width: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.protoMessageName + ".Width"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Width, rhs: Anytype_Rpc.Block.Set.Image.Width) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Width.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.Width.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "width"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Width.Request, rhs: Anytype_Rpc.Block.Set.Image.Width.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.width != rhs.width {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Width.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.Width.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Width.Response, rhs: Anytype_Rpc.Block.Set.Image.Width.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Width.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Image.Width.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Image.Width.Response.Error, rhs: Anytype_Rpc.Block.Set.Image.Width.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Image.Width.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Video"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video, rhs: Anytype_Rpc.Block.Set.Video) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.protoMessageName + ".Name"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Name, rhs: Anytype_Rpc.Block.Set.Video.Name) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Name.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.Name.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Name.Request, rhs: Anytype_Rpc.Block.Set.Video.Name.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Name.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.Name.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Name.Response, rhs: Anytype_Rpc.Block.Set.Video.Name.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Name.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.Name.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Name.Response.Error, rhs: Anytype_Rpc.Block.Set.Video.Name.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Name.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Video.Width: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.protoMessageName + ".Width"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Width, rhs: Anytype_Rpc.Block.Set.Video.Width) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Width.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.Width.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "width"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Width.Request, rhs: Anytype_Rpc.Block.Set.Video.Width.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.width != rhs.width {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Width.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.Width.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Width.Response, rhs: Anytype_Rpc.Block.Set.Video.Width.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Width.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Video.Width.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Video.Width.Response.Error, rhs: Anytype_Rpc.Block.Set.Video.Width.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Video.Width.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Set.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.protoMessageName + ".Link"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Link, rhs: Anytype_Rpc.Block.Set.Link) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Link.protoMessageName + ".TargetBlockId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Link.TargetBlockId, rhs: Anytype_Rpc.Block.Set.Link.TargetBlockId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Link.TargetBlockId.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "targetBlockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetBlockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.targetBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBlockID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Link.TargetBlockId.Request, rhs: Anytype_Rpc.Block.Set.Link.TargetBlockId.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.targetBlockID != rhs.targetBlockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Link.TargetBlockId.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response, rhs: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error, rhs: Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Set.Link.TargetBlockId.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Relation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation, rhs: Anytype_Rpc.Block.Relation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.SetKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.protoMessageName + ".SetKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.SetKey, rhs: Anytype_Rpc.Block.Relation.SetKey) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.SetKey.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.SetKey.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.SetKey.Request, rhs: Anytype_Rpc.Block.Relation.SetKey.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.SetKey.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.SetKey.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.SetKey.Response, rhs: Anytype_Rpc.Block.Relation.SetKey.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.SetKey.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.SetKey.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.SetKey.Response.Error, rhs: Anytype_Rpc.Block.Relation.SetKey.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.SetKey.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Relation.Add: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.protoMessageName + ".Add"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.Add, rhs: Anytype_Rpc.Block.Relation.Add) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.Add.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.Add.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relation"),
  ]

  fileprivate class _StorageClass {
    var _contextID: String = String()
    var _blockID: String = String()
    var _relation: Anytype_Model_Relation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contextID = source._contextID
      _blockID = source._blockID
      _relation = source._relation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contextID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._blockID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._relation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._contextID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contextID, fieldNumber: 1)
      }
      if !_storage._blockID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockID, fieldNumber: 2)
      }
      try { if let v = _storage._relation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.Add.Request, rhs: Anytype_Rpc.Block.Relation.Add.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contextID != rhs_storage._contextID {return false}
        if _storage._blockID != rhs_storage._blockID {return false}
        if _storage._relation != rhs_storage._relation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.Add.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.Add.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.Add.Response, rhs: Anytype_Rpc.Block.Relation.Add.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.Add.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Relation.Add.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Relation.Add.Response.Error, rhs: Anytype_Rpc.Block.Relation.Add.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Relation.Add.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.ObjectType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".ObjectType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ObjectType, rhs: Anytype_Rpc.Block.ObjectType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ObjectType.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ObjectType.protoMessageName + ".Set"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ObjectType.Set, rhs: Anytype_Rpc.Block.ObjectType.Set) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ObjectType.Set.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ObjectType.Set.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    3: .same(proto: "objectTypeUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.objectTypeURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.objectTypeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.objectTypeURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ObjectType.Set.Request, rhs: Anytype_Rpc.Block.ObjectType.Set.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.objectTypeURL != rhs.objectTypeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ObjectType.Set.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ObjectType.Set.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ObjectType.Set.Response, rhs: Anytype_Rpc.Block.ObjectType.Set.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ObjectType.Set.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.ObjectType.Set.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.ObjectType.Set.Response.Error, rhs: Anytype_Rpc.Block.ObjectType.Set.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.ObjectType.Set.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
  ]
}

extension Anytype_Rpc.Block.Bookmark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Bookmark"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark, rhs: Anytype_Rpc.Block.Bookmark) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.protoMessageName + ".Fetch"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.Fetch, rhs: Anytype_Rpc.Block.Bookmark.Fetch) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.Fetch.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.Fetch.Request, rhs: Anytype_Rpc.Block.Bookmark.Fetch.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.Fetch.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.Fetch.Response, rhs: Anytype_Rpc.Block.Bookmark.Fetch.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.Fetch.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.Fetch.Response.Error, rhs: Anytype_Rpc.Block.Bookmark.Fetch.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.Fetch.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.protoMessageName + ".CreateAndFetch"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch, rhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.CreateAndFetch.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "targetId"),
    3: .same(proto: "position"),
    4: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Request, rhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.CreateAndFetch.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response, rhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error, rhs: Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Bookmark.CreateAndFetch.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".File"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.File, rhs: Anytype_Rpc.Block.File) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.File.protoMessageName + ".CreateAndUpload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.File.CreateAndUpload, rhs: Anytype_Rpc.Block.File.CreateAndUpload) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.File.CreateAndUpload.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "targetId"),
    3: .same(proto: "position"),
    4: .same(proto: "url"),
    5: .same(proto: "localPath"),
    6: .same(proto: "fileType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.localPath) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.fileType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.localPath.isEmpty {
      try visitor.visitSingularStringField(value: self.localPath, fieldNumber: 5)
    }
    if self.fileType != .none {
      try visitor.visitSingularEnumField(value: self.fileType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.File.CreateAndUpload.Request, rhs: Anytype_Rpc.Block.File.CreateAndUpload.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.url != rhs.url {return false}
    if lhs.localPath != rhs.localPath {return false}
    if lhs.fileType != rhs.fileType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.File.CreateAndUpload.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.File.CreateAndUpload.Response, rhs: Anytype_Rpc.Block.File.CreateAndUpload.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.File.CreateAndUpload.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.File.CreateAndUpload.Response.Error, rhs: Anytype_Rpc.Block.File.CreateAndUpload.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.File.CreateAndUpload.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Dataview"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview, rhs: Anytype_Rpc.Block.Dataview) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".ViewCreate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewCreate, rhs: Anytype_Rpc.Block.Dataview.ViewCreate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewCreate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewCreate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    4: .same(proto: "view"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._view) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._view {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewCreate.Request, rhs: Anytype_Rpc.Block.Dataview.ViewCreate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._view != rhs._view {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewCreate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewCreate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "viewId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewCreate.Response, rhs: Anytype_Rpc.Block.Dataview.ViewCreate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewCreate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error, rhs: Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewCreate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".ViewUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewUpdate, rhs: Anytype_Rpc.Block.Dataview.ViewUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "viewId"),
    4: .same(proto: "view"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._view) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 3)
    }
    try { if let v = self._view {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewUpdate.Request, rhs: Anytype_Rpc.Block.Dataview.ViewUpdate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs._view != rhs._view {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewUpdate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewUpdate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewUpdate.Response, rhs: Anytype_Rpc.Block.Dataview.ViewUpdate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewUpdate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error, rhs: Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewUpdate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".ViewDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewDelete, rhs: Anytype_Rpc.Block.Dataview.ViewDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewDelete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewDelete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    4: .same(proto: "viewId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewDelete.Request, rhs: Anytype_Rpc.Block.Dataview.ViewDelete.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewDelete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewDelete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewDelete.Response, rhs: Anytype_Rpc.Block.Dataview.ViewDelete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewDelete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error, rhs: Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewDelete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewSetPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".ViewSetPosition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetPosition, rhs: Anytype_Rpc.Block.Dataview.ViewSetPosition) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetPosition.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewSetPosition.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    4: .same(proto: "viewId"),
    5: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 4)
    }
    if self.position != 0 {
      try visitor.visitSingularUInt32Field(value: self.position, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetPosition.Request, rhs: Anytype_Rpc.Block.Dataview.ViewSetPosition.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetPosition.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewSetPosition.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response, rhs: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error, rhs: Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetPosition.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.ViewSetActive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".ViewSetActive"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetActive, rhs: Anytype_Rpc.Block.Dataview.ViewSetActive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetActive.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewSetActive.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "viewId"),
    4: .same(proto: "offset"),
    5: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 4)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetActive.Request, rhs: Anytype_Rpc.Block.Dataview.ViewSetActive.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetActive.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewSetActive.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetActive.Response, rhs: Anytype_Rpc.Block.Dataview.ViewSetActive.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.ViewSetActive.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error, rhs: Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.ViewSetActive.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RecordUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordUpdate, rhs: Anytype_Rpc.Block.Dataview.RecordUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "recordId"),
    4: .same(proto: "record"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recordID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.recordID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordID, fieldNumber: 3)
    }
    try { if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordUpdate.Request, rhs: Anytype_Rpc.Block.Dataview.RecordUpdate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.recordID != rhs.recordID {return false}
    if lhs._record != rhs._record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordUpdate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordUpdate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordUpdate.Response, rhs: Anytype_Rpc.Block.Dataview.RecordUpdate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordUpdate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordUpdate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RecordDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordDelete, rhs: Anytype_Rpc.Block.Dataview.RecordDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordDelete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordDelete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "recordId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recordID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.recordID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordDelete.Request, rhs: Anytype_Rpc.Block.Dataview.RecordDelete.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.recordID != rhs.recordID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordDelete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordDelete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordDelete.Response, rhs: Anytype_Rpc.Block.Dataview.RecordDelete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordDelete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordDelete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RecordCreate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordCreate, rhs: Anytype_Rpc.Block.Dataview.RecordCreate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordCreate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordCreate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "record"),
    4: .same(proto: "templateId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordCreate.Request, rhs: Anytype_Rpc.Block.Dataview.RecordCreate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._record != rhs._record {return false}
    if lhs.templateID != rhs.templateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordCreate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordCreate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "record"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordCreate.Response, rhs: Anytype_Rpc.Block.Dataview.RecordCreate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._record != rhs._record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordCreate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordCreate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RelationAdd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationAdd, rhs: Anytype_Rpc.Block.Dataview.RelationAdd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationAdd.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationAdd.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relation"),
  ]

  fileprivate class _StorageClass {
    var _contextID: String = String()
    var _blockID: String = String()
    var _relation: Anytype_Model_Relation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contextID = source._contextID
      _blockID = source._blockID
      _relation = source._relation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contextID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._blockID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._relation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._contextID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contextID, fieldNumber: 1)
      }
      if !_storage._blockID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockID, fieldNumber: 2)
      }
      try { if let v = _storage._relation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationAdd.Request, rhs: Anytype_Rpc.Block.Dataview.RelationAdd.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contextID != rhs_storage._contextID {return false}
        if _storage._blockID != rhs_storage._blockID {return false}
        if _storage._relation != rhs_storage._relation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationAdd.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationAdd.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "relationKey"),
    4: .same(proto: "relation"),
  ]

  fileprivate class _StorageClass {
    var _error: Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error? = nil
    var _event: Anytype_ResponseEvent? = nil
    var _relationKey: String = String()
    var _relation: Anytype_Model_Relation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _error = source._error
      _event = source._event
      _relationKey = source._relationKey
      _relation = source._relation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._relationKey) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._relation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._relationKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relationKey, fieldNumber: 3)
      }
      try { if let v = _storage._relation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationAdd.Response, rhs: Anytype_Rpc.Block.Dataview.RelationAdd.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._error != rhs_storage._error {return false}
        if _storage._event != rhs_storage._event {return false}
        if _storage._relationKey != rhs_storage._relationKey {return false}
        if _storage._relation != rhs_storage._relation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationAdd.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationAdd.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RelationUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationUpdate, rhs: Anytype_Rpc.Block.Dataview.RelationUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relationKey"),
    4: .same(proto: "relation"),
  ]

  fileprivate class _StorageClass {
    var _contextID: String = String()
    var _blockID: String = String()
    var _relationKey: String = String()
    var _relation: Anytype_Model_Relation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contextID = source._contextID
      _blockID = source._blockID
      _relationKey = source._relationKey
      _relation = source._relation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contextID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._blockID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._relationKey) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._relation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._contextID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contextID, fieldNumber: 1)
      }
      if !_storage._blockID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockID, fieldNumber: 2)
      }
      if !_storage._relationKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relationKey, fieldNumber: 3)
      }
      try { if let v = _storage._relation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationUpdate.Request, rhs: Anytype_Rpc.Block.Dataview.RelationUpdate.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contextID != rhs_storage._contextID {return false}
        if _storage._blockID != rhs_storage._blockID {return false}
        if _storage._relationKey != rhs_storage._relationKey {return false}
        if _storage._relation != rhs_storage._relation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationUpdate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationUpdate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationUpdate.Response, rhs: Anytype_Rpc.Block.Dataview.RelationUpdate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationUpdate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationUpdate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RelationDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationDelete, rhs: Anytype_Rpc.Block.Dataview.RelationDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationDelete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationDelete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relationKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationDelete.Request, rhs: Anytype_Rpc.Block.Dataview.RelationDelete.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationDelete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationDelete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationDelete.Response, rhs: Anytype_Rpc.Block.Dataview.RelationDelete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationDelete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationDelete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RecordRelationOptionAdd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relationKey"),
    4: .same(proto: "option"),
    5: .same(proto: "recordId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.recordID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 3)
    }
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.recordID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Request, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs._option != rhs._option {return false}
    if lhs.recordID != rhs.recordID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionAdd.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RecordRelationOptionUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relationKey"),
    4: .same(proto: "option"),
    5: .same(proto: "recordId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.recordID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 3)
    }
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.recordID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Request, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs._option != rhs._option {return false}
    if lhs.recordID != rhs.recordID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionUpdate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RecordRelationOptionDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "relationKey"),
    4: .same(proto: "optionId"),
    5: .same(proto: "recordId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.optionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.recordID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 3)
    }
    if !self.optionID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionID, fieldNumber: 4)
    }
    if !self.recordID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Request, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.optionID != rhs.optionID {return false}
    if lhs.recordID != rhs.recordID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RecordRelationOptionDelete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Dataview.RelationListAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".RelationListAvailable"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationListAvailable, rhs: Anytype_Rpc.Block.Dataview.RelationListAvailable) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationListAvailable.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationListAvailable.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationListAvailable.Request, rhs: Anytype_Rpc.Block.Dataview.RelationListAvailable.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationListAvailable.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationListAvailable.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response, rhs: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error, rhs: Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.RelationListAvailable.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "NOT_A_DATAVIEW_BLOCK"),
  ]
}

extension Anytype_Rpc.Block.Dataview.SetSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.protoMessageName + ".SetSource"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.SetSource, rhs: Anytype_Rpc.Block.Dataview.SetSource) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.SetSource.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.SetSource.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitRepeatedStringField(value: self.source, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.SetSource.Request, rhs: Anytype_Rpc.Block.Dataview.SetSource.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.SetSource.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.SetSource.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    4: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.SetSource.Response, rhs: Anytype_Rpc.Block.Dataview.SetSource.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.SetSource.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Dataview.SetSource.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Dataview.SetSource.Response.Error, rhs: Anytype_Rpc.Block.Dataview.SetSource.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Dataview.SetSource.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Get: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Get"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Get, rhs: Anytype_Rpc.Block.Get) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Get.Marks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Get.protoMessageName + ".Marks"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Get.Marks, rhs: Anytype_Rpc.Block.Get.Marks) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Get.Marks.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Get.Marks.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Get.Marks.Request, rhs: Anytype_Rpc.Block.Get.Marks.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._range != rhs._range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Get.Marks.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Get.Marks.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Get.Marks.Response, rhs: Anytype_Rpc.Block.Get.Marks.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Get.Marks.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Get.Marks.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Get.Marks.Response.Error, rhs: Anytype_Rpc.Block.Get.Marks.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Get.Marks.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.UndoRedoCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".UndoRedoCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "undo"),
    2: .same(proto: "redo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.undo) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.redo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.undo != 0 {
      try visitor.visitSingularInt32Field(value: self.undo, fieldNumber: 1)
    }
    if self.redo != 0 {
      try visitor.visitSingularInt32Field(value: self.redo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.UndoRedoCounter, rhs: Anytype_Rpc.Block.UndoRedoCounter) -> Bool {
    if lhs.undo != rhs.undo {return false}
    if lhs.redo != rhs.redo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Undo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Undo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Undo, rhs: Anytype_Rpc.Block.Undo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Undo.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Undo.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Undo.Request, rhs: Anytype_Rpc.Block.Undo.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Undo.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Undo.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "counters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._counters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._counters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Undo.Response, rhs: Anytype_Rpc.Block.Undo.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs._counters != rhs._counters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Undo.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Undo.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Undo.Response.Error, rhs: Anytype_Rpc.Block.Undo.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Undo.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "CAN_NOT_MOVE"),
  ]
}

extension Anytype_Rpc.Block.Redo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Redo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Redo, rhs: Anytype_Rpc.Block.Redo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Redo.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Redo.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Redo.Request, rhs: Anytype_Rpc.Block.Redo.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Redo.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Redo.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "counters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._counters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._counters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Redo.Response, rhs: Anytype_Rpc.Block.Redo.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs._counters != rhs._counters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Redo.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Redo.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Redo.Response.Error, rhs: Anytype_Rpc.Block.Redo.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Redo.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "CAN_NOT_MOVE"),
  ]
}

extension Anytype_Rpc.Block.Open: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Open"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Open, rhs: Anytype_Rpc.Block.Open) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Open.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Open.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "traceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Open.Request, rhs: Anytype_Rpc.Block.Open.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Open.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Open.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Open.Response, rhs: Anytype_Rpc.Block.Open.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Open.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Open.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Open.Response.Error, rhs: Anytype_Rpc.Block.Open.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Open.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "NOT_FOUND"),
    10: .same(proto: "ANYTYPE_NEEDS_UPGRADE"),
  ]
}

extension Anytype_Rpc.Block.Show: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Show"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Show, rhs: Anytype_Rpc.Block.Show) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Show.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Show.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
    3: .same(proto: "traceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Show.Request, rhs: Anytype_Rpc.Block.Show.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Show.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Show.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Show.Response, rhs: Anytype_Rpc.Block.Show.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Show.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Show.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Show.Response.Error, rhs: Anytype_Rpc.Block.Show.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Show.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "NOT_FOUND"),
    10: .same(proto: "ANYTYPE_NEEDS_UPGRADE"),
  ]
}

extension Anytype_Rpc.Block.GetPublicWebURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".GetPublicWebURL"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.GetPublicWebURL, rhs: Anytype_Rpc.Block.GetPublicWebURL) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.GetPublicWebURL.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.GetPublicWebURL.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.GetPublicWebURL.Request, rhs: Anytype_Rpc.Block.GetPublicWebURL.Request) -> Bool {
    if lhs.blockID != rhs.blockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.GetPublicWebURL.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.GetPublicWebURL.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.GetPublicWebURL.Response, rhs: Anytype_Rpc.Block.GetPublicWebURL.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.GetPublicWebURL.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.GetPublicWebURL.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.GetPublicWebURL.Response.Error, rhs: Anytype_Rpc.Block.GetPublicWebURL.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.GetPublicWebURL.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.OpenBreadcrumbs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".OpenBreadcrumbs"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.OpenBreadcrumbs, rhs: Anytype_Rpc.Block.OpenBreadcrumbs) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.OpenBreadcrumbs.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.OpenBreadcrumbs.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "traceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.OpenBreadcrumbs.Request, rhs: Anytype_Rpc.Block.OpenBreadcrumbs.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.OpenBreadcrumbs.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.OpenBreadcrumbs.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.OpenBreadcrumbs.Response, rhs: Anytype_Rpc.Block.OpenBreadcrumbs.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.OpenBreadcrumbs.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error, rhs: Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.OpenBreadcrumbs.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.SetBreadcrumbs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".SetBreadcrumbs"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.SetBreadcrumbs, rhs: Anytype_Rpc.Block.SetBreadcrumbs) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.SetBreadcrumbs.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.SetBreadcrumbs.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "breadcrumbsId"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.breadcrumbsID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.breadcrumbsID.isEmpty {
      try visitor.visitSingularStringField(value: self.breadcrumbsID, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.SetBreadcrumbs.Request, rhs: Anytype_Rpc.Block.SetBreadcrumbs.Request) -> Bool {
    if lhs.breadcrumbsID != rhs.breadcrumbsID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.SetBreadcrumbs.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.SetBreadcrumbs.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.SetBreadcrumbs.Response, rhs: Anytype_Rpc.Block.SetBreadcrumbs.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.SetBreadcrumbs.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.SetBreadcrumbs.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.SetBreadcrumbs.Response.Error, rhs: Anytype_Rpc.Block.SetBreadcrumbs.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.SetBreadcrumbs.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Create, rhs: Anytype_Rpc.Block.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "targetId"),
    3: .same(proto: "block"),
    4: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Create.Request, rhs: Anytype_Rpc.Block.Create.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs._block != rhs._block {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Create.Response, rhs: Anytype_Rpc.Block.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Create.Response.Error, rhs: Anytype_Rpc.Block.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.CreatePage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".CreatePage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreatePage, rhs: Anytype_Rpc.Block.CreatePage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreatePage.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.CreatePage.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    3: .same(proto: "details"),
    5: .same(proto: "templateId"),
    2: .same(proto: "targetId"),
    4: .same(proto: "position"),
    6: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 4)
    }
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 5)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreatePage.Request, rhs: Anytype_Rpc.Block.CreatePage.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.templateID != rhs.templateID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.position != rhs.position {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreatePage.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.CreatePage.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "targetId"),
    4: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 3)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreatePage.Response, rhs: Anytype_Rpc.Block.CreatePage.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreatePage.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.CreatePage.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreatePage.Response.Error, rhs: Anytype_Rpc.Block.CreatePage.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreatePage.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.CreateSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".CreateSet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreateSet, rhs: Anytype_Rpc.Block.CreateSet) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreateSet.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.CreateSet.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "targetId"),
    3: .same(proto: "source"),
    4: .same(proto: "details"),
    5: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitRepeatedStringField(value: self.source, fieldNumber: 3)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.position != .none {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreateSet.Request, rhs: Anytype_Rpc.Block.CreateSet.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.source != rhs.source {return false}
    if lhs._details != rhs._details {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreateSet.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.CreateSet.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "blockId"),
    3: .same(proto: "targetId"),
    4: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 3)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreateSet.Response, rhs: Anytype_Rpc.Block.CreateSet.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreateSet.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.CreateSet.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.CreateSet.Response.Error, rhs: Anytype_Rpc.Block.CreateSet.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.CreateSet.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
  ]
}

extension Anytype_Rpc.Block.Unlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Unlink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Unlink, rhs: Anytype_Rpc.Block.Unlink) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Unlink.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Unlink.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.blockIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Unlink.Request, rhs: Anytype_Rpc.Block.Unlink.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockIds != rhs.blockIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Unlink.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Unlink.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Unlink.Response, rhs: Anytype_Rpc.Block.Unlink.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Unlink.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Unlink.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Unlink.Response.Error, rhs: Anytype_Rpc.Block.Unlink.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Unlink.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Block.Close: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.protoMessageName + ".Close"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Close, rhs: Anytype_Rpc.Block.Close) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Close.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Close.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "blockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Close.Request, rhs: Anytype_Rpc.Block.Close.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.blockID != rhs.blockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Close.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Close.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Close.Response, rhs: Anytype_Rpc.Block.Close.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Close.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Block.Close.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Block.Close.Response.Error, rhs: Anytype_Rpc.Block.Close.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Block.Close.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Workspace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Workspace"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace, rhs: Anytype_Rpc.Workspace) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetCurrent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.protoMessageName + ".GetCurrent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetCurrent, rhs: Anytype_Rpc.Workspace.GetCurrent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetCurrent.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.GetCurrent.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetCurrent.Request, rhs: Anytype_Rpc.Workspace.GetCurrent.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetCurrent.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.GetCurrent.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "workspaceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workspaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetCurrent.Response, rhs: Anytype_Rpc.Workspace.GetCurrent.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.workspaceID != rhs.workspaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetCurrent.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.GetCurrent.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetCurrent.Response.Error, rhs: Anytype_Rpc.Workspace.GetCurrent.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetCurrent.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Workspace.GetAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.protoMessageName + ".GetAll"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetAll, rhs: Anytype_Rpc.Workspace.GetAll) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetAll.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.GetAll.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetAll.Request, rhs: Anytype_Rpc.Workspace.GetAll.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetAll.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.GetAll.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "workspaceIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.workspaceIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workspaceIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.workspaceIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetAll.Response, rhs: Anytype_Rpc.Workspace.GetAll.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.workspaceIds != rhs.workspaceIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetAll.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.GetAll.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.GetAll.Response.Error, rhs: Anytype_Rpc.Workspace.GetAll.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.GetAll.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Workspace.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Create, rhs: Anytype_Rpc.Workspace.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Create.Request, rhs: Anytype_Rpc.Workspace.Create.Request) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "workspaceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workspaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Create.Response, rhs: Anytype_Rpc.Workspace.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.workspaceID != rhs.workspaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Create.Response.Error, rhs: Anytype_Rpc.Workspace.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Workspace.SetIsHighlighted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.protoMessageName + ".SetIsHighlighted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.SetIsHighlighted, rhs: Anytype_Rpc.Workspace.SetIsHighlighted) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.SetIsHighlighted.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.SetIsHighlighted.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
    2: .same(proto: "isHighlighted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isHighlighted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.isHighlighted != false {
      try visitor.visitSingularBoolField(value: self.isHighlighted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.SetIsHighlighted.Request, rhs: Anytype_Rpc.Workspace.SetIsHighlighted.Request) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.isHighlighted != rhs.isHighlighted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.SetIsHighlighted.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.SetIsHighlighted.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.SetIsHighlighted.Response, rhs: Anytype_Rpc.Workspace.SetIsHighlighted.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.SetIsHighlighted.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error, rhs: Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.SetIsHighlighted.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Workspace.Select: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.protoMessageName + ".Select"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Select, rhs: Anytype_Rpc.Workspace.Select) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Select.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.Select.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workspaceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workspaceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workspaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Select.Request, rhs: Anytype_Rpc.Workspace.Select.Request) -> Bool {
    if lhs.workspaceID != rhs.workspaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Select.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.Select.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Select.Response, rhs: Anytype_Rpc.Workspace.Select.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Select.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Workspace.Select.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Workspace.Select.Response.Error, rhs: Anytype_Rpc.Workspace.Select.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Workspace.Select.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Wallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Wallet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet, rhs: Anytype_Rpc.Wallet) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Create, rhs: Anytype_Rpc.Wallet.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootPath.isEmpty {
      try visitor.visitSingularStringField(value: self.rootPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Create.Request, rhs: Anytype_Rpc.Wallet.Create.Request) -> Bool {
    if lhs.rootPath != rhs.rootPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "mnemonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Create.Response, rhs: Anytype_Rpc.Wallet.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Create.Response.Error, rhs: Anytype_Rpc.Wallet.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "FAILED_TO_CREATE_LOCAL_REPO"),
  ]
}

extension Anytype_Rpc.Wallet.Recover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.protoMessageName + ".Recover"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Recover, rhs: Anytype_Rpc.Wallet.Recover) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Recover.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Recover.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootPath"),
    2: .same(proto: "mnemonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootPath.isEmpty {
      try visitor.visitSingularStringField(value: self.rootPath, fieldNumber: 1)
    }
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Recover.Request, rhs: Anytype_Rpc.Wallet.Recover.Request) -> Bool {
    if lhs.rootPath != rhs.rootPath {return false}
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Recover.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Recover.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Recover.Response, rhs: Anytype_Rpc.Wallet.Recover.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Recover.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Recover.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Recover.Response.Error, rhs: Anytype_Rpc.Wallet.Recover.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Recover.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "FAILED_TO_CREATE_LOCAL_REPO"),
  ]
}

extension Anytype_Rpc.Wallet.Convert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.protoMessageName + ".Convert"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Convert, rhs: Anytype_Rpc.Wallet.Convert) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Convert.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Convert.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .same(proto: "entropy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entropy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if !self.entropy.isEmpty {
      try visitor.visitSingularStringField(value: self.entropy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Convert.Request, rhs: Anytype_Rpc.Wallet.Convert.Request) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.entropy != rhs.entropy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Convert.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Convert.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "entropy"),
    3: .same(proto: "mnemonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entropy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.entropy.isEmpty {
      try visitor.visitSingularStringField(value: self.entropy, fieldNumber: 2)
    }
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Convert.Response, rhs: Anytype_Rpc.Wallet.Convert.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.entropy != rhs.entropy {return false}
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Convert.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Wallet.Convert.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Wallet.Convert.Response.Error, rhs: Anytype_Rpc.Wallet.Convert.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Wallet.Convert.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Account"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account, rhs: Anytype_Rpc.Account) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.protoMessageName + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enableDataview"),
    2: .same(proto: "enableDebug"),
    3: .same(proto: "enableReleaseChannelSwitch"),
    4: .same(proto: "enableSpaces"),
    100: .same(proto: "extra"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableDataview) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableDebug) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enableReleaseChannelSwitch) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableSpaces) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enableDataview != false {
      try visitor.visitSingularBoolField(value: self.enableDataview, fieldNumber: 1)
    }
    if self.enableDebug != false {
      try visitor.visitSingularBoolField(value: self.enableDebug, fieldNumber: 2)
    }
    if self.enableReleaseChannelSwitch != false {
      try visitor.visitSingularBoolField(value: self.enableReleaseChannelSwitch, fieldNumber: 3)
    }
    if self.enableSpaces != false {
      try visitor.visitSingularBoolField(value: self.enableSpaces, fieldNumber: 4)
    }
    try { if let v = self._extra {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Config, rhs: Anytype_Rpc.Account.Config) -> Bool {
    if lhs.enableDataview != rhs.enableDataview {return false}
    if lhs.enableDebug != rhs.enableDebug {return false}
    if lhs.enableReleaseChannelSwitch != rhs.enableReleaseChannelSwitch {return false}
    if lhs.enableSpaces != rhs.enableSpaces {return false}
    if lhs._extra != rhs._extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Create, rhs: Anytype_Rpc.Account.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "avatarLocalPath"),
    3: .same(proto: "avatarColor"),
    20: .same(proto: "alphaInviteCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.avatar != nil {try decoder.handleConflictingOneOf()}
          self.avatar = .avatarLocalPath(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.avatar != nil {try decoder.handleConflictingOneOf()}
          self.avatar = .avatarColor(v)
        }
      }()
      case 20: try { try decoder.decodeSingularStringField(value: &self.alphaInviteCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.avatar {
    case .avatarLocalPath?: try {
      guard case .avatarLocalPath(let v)? = self.avatar else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .avatarColor?: try {
      guard case .avatarColor(let v)? = self.avatar else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.alphaInviteCode.isEmpty {
      try visitor.visitSingularStringField(value: self.alphaInviteCode, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Create.Request, rhs: Anytype_Rpc.Account.Create.Request) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.alphaInviteCode != rhs.alphaInviteCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "account"),
    3: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Create.Response, rhs: Anytype_Rpc.Account.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._account != rhs._account {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Create.Response.Error, rhs: Anytype_Rpc.Account.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE"),
    102: .same(proto: "ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME"),
    103: .same(proto: "ACCOUNT_CREATED_BUT_FAILED_TO_SET_AVATAR"),
    104: .same(proto: "FAILED_TO_STOP_RUNNING_NODE"),
    900: .same(proto: "BAD_INVITE_CODE"),
  ]
}

extension Anytype_Rpc.Account.Recover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.protoMessageName + ".Recover"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Recover, rhs: Anytype_Rpc.Account.Recover) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Recover.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Recover.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Recover.Request, rhs: Anytype_Rpc.Account.Recover.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Recover.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Recover.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Recover.Response, rhs: Anytype_Rpc.Account.Recover.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Recover.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Recover.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Recover.Response.Error, rhs: Anytype_Rpc.Account.Recover.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Recover.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "NO_ACCOUNTS_FOUND"),
    102: .same(proto: "NEED_TO_RECOVER_WALLET_FIRST"),
    103: .same(proto: "FAILED_TO_CREATE_LOCAL_REPO"),
    104: .same(proto: "LOCAL_REPO_EXISTS_BUT_CORRUPTED"),
    105: .same(proto: "FAILED_TO_RUN_NODE"),
    106: .same(proto: "WALLET_RECOVER_NOT_PERFORMED"),
    107: .same(proto: "FAILED_TO_STOP_RUNNING_NODE"),
    108: .same(proto: "ANOTHER_ANYTYPE_PROCESS_IS_RUNNING"),
  ]
}

extension Anytype_Rpc.Account.Select: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.protoMessageName + ".Select"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Select, rhs: Anytype_Rpc.Account.Select) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Select.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Select.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "rootPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rootPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.rootPath.isEmpty {
      try visitor.visitSingularStringField(value: self.rootPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Select.Request, rhs: Anytype_Rpc.Account.Select.Request) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rootPath != rhs.rootPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Select.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Select.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "account"),
    3: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Select.Response, rhs: Anytype_Rpc.Account.Select.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._account != rhs._account {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Select.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Select.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Select.Response.Error, rhs: Anytype_Rpc.Account.Select.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Select.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "FAILED_TO_CREATE_LOCAL_REPO"),
    102: .same(proto: "LOCAL_REPO_EXISTS_BUT_CORRUPTED"),
    103: .same(proto: "FAILED_TO_RUN_NODE"),
    104: .same(proto: "FAILED_TO_FIND_ACCOUNT_INFO"),
    105: .same(proto: "LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET"),
    106: .same(proto: "FAILED_TO_STOP_SEARCHER_NODE"),
    107: .same(proto: "FAILED_TO_RECOVER_PREDEFINED_BLOCKS"),
    108: .same(proto: "ANOTHER_ANYTYPE_PROCESS_IS_RUNNING"),
  ]
}

extension Anytype_Rpc.Account.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.protoMessageName + ".Stop"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Stop, rhs: Anytype_Rpc.Account.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Stop.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Stop.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removeData"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.removeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.removeData != false {
      try visitor.visitSingularBoolField(value: self.removeData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Stop.Request, rhs: Anytype_Rpc.Account.Stop.Request) -> Bool {
    if lhs.removeData != rhs.removeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Stop.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Stop.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Stop.Response, rhs: Anytype_Rpc.Account.Stop.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Stop.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Account.Stop.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Account.Stop.Response.Error, rhs: Anytype_Rpc.Account.Stop.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Account.Stop.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "ACCOUNT_IS_NOT_RUNNING"),
    102: .same(proto: "FAILED_TO_STOP_NODE"),
    103: .same(proto: "FAILED_TO_REMOVE_ACCOUNT_DATA"),
  ]
}

extension Anytype_Rpc.Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Log"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Log, rhs: Anytype_Rpc.Log) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Log.Send: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Log.protoMessageName + ".Send"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Log.Send, rhs: Anytype_Rpc.Log.Send) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Log.Send.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Log.Send.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.level != .debug {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Log.Send.Request, rhs: Anytype_Rpc.Log.Send.Request) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Log.Send.Request.Level: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEBUG"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "FATAL"),
    3: .same(proto: "INFO"),
    4: .same(proto: "PANIC"),
    5: .same(proto: "WARNING"),
  ]
}

extension Anytype_Rpc.Log.Send.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Log.Send.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Log.Send.Response, rhs: Anytype_Rpc.Log.Send.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Log.Send.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Log.Send.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Log.Send.Response.Error, rhs: Anytype_Rpc.Log.Send.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Log.Send.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "NOT_FOUND"),
    102: .same(proto: "TIMEOUT"),
  ]
}

extension Anytype_Rpc.Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Version"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Version, rhs: Anytype_Rpc.Version) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Version.Get: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Version.protoMessageName + ".Get"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Version.Get, rhs: Anytype_Rpc.Version.Get) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Version.Get.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Version.Get.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Version.Get.Request, rhs: Anytype_Rpc.Version.Get.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Version.Get.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Version.Get.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "version"),
    3: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Version.Get.Response, rhs: Anytype_Rpc.Version.Get.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.version != rhs.version {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Version.Get.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Version.Get.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Version.Get.Response.Error, rhs: Anytype_Rpc.Version.Get.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Version.Get.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "VERSION_IS_EMPTY"),
    101: .same(proto: "NOT_FOUND"),
    102: .same(proto: "TIMEOUT"),
  ]
}

extension Anytype_Rpc.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".File"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.File, rhs: Anytype_Rpc.File) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.File.Offload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.File.protoMessageName + ".Offload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.File.Offload, rhs: Anytype_Rpc.File.Offload) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.File.Offload.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.File.Offload.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "includeNotPinned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeNotPinned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.includeNotPinned != false {
      try visitor.visitSingularBoolField(value: self.includeNotPinned, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.File.Offload.Request, rhs: Anytype_Rpc.File.Offload.Request) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.includeNotPinned != rhs.includeNotPinned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.File.Offload.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.File.Offload.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "bytesOffloaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bytesOffloaded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.bytesOffloaded != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesOffloaded, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.File.Offload.Response, rhs: Anytype_Rpc.File.Offload.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.bytesOffloaded != rhs.bytesOffloaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.File.Offload.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.File.Offload.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.File.Offload.Response.Error, rhs: Anytype_Rpc.File.Offload.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.File.Offload.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    103: .same(proto: "NODE_NOT_STARTED"),
    104: .same(proto: "FILE_NOT_YET_PINNED"),
  ]
}

extension Anytype_Rpc.FileList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".FileList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.FileList, rhs: Anytype_Rpc.FileList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.FileList.Offload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.FileList.protoMessageName + ".Offload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.FileList.Offload, rhs: Anytype_Rpc.FileList.Offload) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.FileList.Offload.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.FileList.Offload.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "onlyIds"),
    2: .same(proto: "includeNotPinned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.onlyIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeNotPinned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.onlyIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.onlyIds, fieldNumber: 1)
    }
    if self.includeNotPinned != false {
      try visitor.visitSingularBoolField(value: self.includeNotPinned, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.FileList.Offload.Request, rhs: Anytype_Rpc.FileList.Offload.Request) -> Bool {
    if lhs.onlyIds != rhs.onlyIds {return false}
    if lhs.includeNotPinned != rhs.includeNotPinned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.FileList.Offload.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.FileList.Offload.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "filesOffloaded"),
    3: .same(proto: "bytesOffloaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.filesOffloaded) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.bytesOffloaded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.filesOffloaded != 0 {
      try visitor.visitSingularInt32Field(value: self.filesOffloaded, fieldNumber: 2)
    }
    if self.bytesOffloaded != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesOffloaded, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.FileList.Offload.Response, rhs: Anytype_Rpc.FileList.Offload.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.filesOffloaded != rhs.filesOffloaded {return false}
    if lhs.bytesOffloaded != rhs.bytesOffloaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.FileList.Offload.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.FileList.Offload.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.FileList.Offload.Response.Error, rhs: Anytype_Rpc.FileList.Offload.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.FileList.Offload.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    103: .same(proto: "NODE_NOT_STARTED"),
  ]
}

extension Anytype_Rpc.Shutdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Shutdown"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Shutdown, rhs: Anytype_Rpc.Shutdown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Shutdown.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Shutdown.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Shutdown.Request, rhs: Anytype_Rpc.Shutdown.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Shutdown.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Shutdown.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Shutdown.Response, rhs: Anytype_Rpc.Shutdown.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Shutdown.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Shutdown.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Shutdown.Response.Error, rhs: Anytype_Rpc.Shutdown.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Shutdown.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "NODE_NOT_STARTED"),
  ]
}

extension Anytype_Rpc.Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Config"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Config, rhs: Anytype_Rpc.Config) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Config.Get: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Config.protoMessageName + ".Get"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Config.Get, rhs: Anytype_Rpc.Config.Get) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Config.Get.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Config.Get.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Config.Get.Request, rhs: Anytype_Rpc.Config.Get.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Config.Get.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Config.Get.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "homeBlockId"),
    3: .same(proto: "archiveBlockId"),
    4: .same(proto: "profileBlockId"),
    5: .same(proto: "marketplaceTypeId"),
    6: .same(proto: "marketplaceRelationId"),
    7: .same(proto: "marketplaceTemplateId"),
    101: .same(proto: "gatewayUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeBlockID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.archiveBlockID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.profileBlockID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.marketplaceTypeID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.marketplaceRelationID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marketplaceTemplateID) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self.gatewayURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.homeBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.homeBlockID, fieldNumber: 2)
    }
    if !self.archiveBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.archiveBlockID, fieldNumber: 3)
    }
    if !self.profileBlockID.isEmpty {
      try visitor.visitSingularStringField(value: self.profileBlockID, fieldNumber: 4)
    }
    if !self.marketplaceTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketplaceTypeID, fieldNumber: 5)
    }
    if !self.marketplaceRelationID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketplaceRelationID, fieldNumber: 6)
    }
    if !self.marketplaceTemplateID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketplaceTemplateID, fieldNumber: 7)
    }
    if !self.gatewayURL.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayURL, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Config.Get.Response, rhs: Anytype_Rpc.Config.Get.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.homeBlockID != rhs.homeBlockID {return false}
    if lhs.archiveBlockID != rhs.archiveBlockID {return false}
    if lhs.profileBlockID != rhs.profileBlockID {return false}
    if lhs.marketplaceTypeID != rhs.marketplaceTypeID {return false}
    if lhs.marketplaceRelationID != rhs.marketplaceRelationID {return false}
    if lhs.marketplaceTemplateID != rhs.marketplaceTemplateID {return false}
    if lhs.gatewayURL != rhs.gatewayURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Config.Get.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Config.Get.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Config.Get.Response.Error, rhs: Anytype_Rpc.Config.Get.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Config.Get.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    101: .same(proto: "NODE_NOT_STARTED"),
  ]
}

extension Anytype_Rpc.Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Ping, rhs: Anytype_Rpc.Ping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Ping.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Ping.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "numberOfEventsToSend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numberOfEventsToSend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.numberOfEventsToSend != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfEventsToSend, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Ping.Request, rhs: Anytype_Rpc.Ping.Request) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.numberOfEventsToSend != rhs.numberOfEventsToSend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Ping.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Ping.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Ping.Response, rhs: Anytype_Rpc.Ping.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Ping.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Ping.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Ping.Response.Error, rhs: Anytype_Rpc.Ping.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Ping.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Process: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Process"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Process, rhs: Anytype_Rpc.Process) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Process.Cancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Process.protoMessageName + ".Cancel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Process.Cancel, rhs: Anytype_Rpc.Process.Cancel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Process.Cancel.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Process.Cancel.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Process.Cancel.Request, rhs: Anytype_Rpc.Process.Cancel.Request) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Process.Cancel.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Process.Cancel.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Process.Cancel.Response, rhs: Anytype_Rpc.Process.Cancel.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Process.Cancel.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Process.Cancel.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Process.Cancel.Response.Error, rhs: Anytype_Rpc.Process.Cancel.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Process.Cancel.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".LinkPreview"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.LinkPreview, rhs: Anytype_Rpc.LinkPreview) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.LinkPreview.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.LinkPreview.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.LinkPreview.Request, rhs: Anytype_Rpc.LinkPreview.Request) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.LinkPreview.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.LinkPreview.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "linkPreview"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._linkPreview) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._linkPreview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.LinkPreview.Response, rhs: Anytype_Rpc.LinkPreview.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._linkPreview != rhs._linkPreview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.LinkPreview.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.LinkPreview.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.LinkPreview.Response.Error, rhs: Anytype_Rpc.LinkPreview.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.LinkPreview.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.UploadFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".UploadFile"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.UploadFile, rhs: Anytype_Rpc.UploadFile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.UploadFile.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.UploadFile.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "localPath"),
    3: .same(proto: "type"),
    4: .same(proto: "disableEncryption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localPath) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableEncryption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.localPath.isEmpty {
      try visitor.visitSingularStringField(value: self.localPath, fieldNumber: 2)
    }
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.disableEncryption != false {
      try visitor.visitSingularBoolField(value: self.disableEncryption, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.UploadFile.Request, rhs: Anytype_Rpc.UploadFile.Request) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.localPath != rhs.localPath {return false}
    if lhs.type != rhs.type {return false}
    if lhs.disableEncryption != rhs.disableEncryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.UploadFile.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.UploadFile.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.UploadFile.Response, rhs: Anytype_Rpc.UploadFile.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.UploadFile.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.UploadFile.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.UploadFile.Response.Error, rhs: Anytype_Rpc.UploadFile.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.UploadFile.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.DownloadFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".DownloadFile"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.DownloadFile, rhs: Anytype_Rpc.DownloadFile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.DownloadFile.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.DownloadFile.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.DownloadFile.Request, rhs: Anytype_Rpc.DownloadFile.Request) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.DownloadFile.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.DownloadFile.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "localPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.localPath.isEmpty {
      try visitor.visitSingularStringField(value: self.localPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.DownloadFile.Response, rhs: Anytype_Rpc.DownloadFile.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.localPath != rhs.localPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.DownloadFile.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.DownloadFile.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.DownloadFile.Response.Error, rhs: Anytype_Rpc.DownloadFile.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.DownloadFile.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "NOT_FOUND"),
  ]
}

extension Anytype_Rpc.Navigation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Navigation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation, rhs: Anytype_Rpc.Navigation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.Context: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Navigation"),
    1: .same(proto: "MoveTo"),
    2: .same(proto: "LinkTo"),
  ]
}

extension Anytype_Rpc.Navigation.ListObjects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.protoMessageName + ".ListObjects"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.ListObjects, rhs: Anytype_Rpc.Navigation.ListObjects) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.ListObjects.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.ListObjects.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "fullText"),
    3: .same(proto: "limit"),
    4: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullText) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.context != .navigation {
      try visitor.visitSingularEnumField(value: self.context, fieldNumber: 1)
    }
    if !self.fullText.isEmpty {
      try visitor.visitSingularStringField(value: self.fullText, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.ListObjects.Request, rhs: Anytype_Rpc.Navigation.ListObjects.Request) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.fullText != rhs.fullText {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.ListObjects.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.ListObjects.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "objects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.ListObjects.Response, rhs: Anytype_Rpc.Navigation.ListObjects.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.ListObjects.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.ListObjects.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.ListObjects.Response.Error, rhs: Anytype_Rpc.Navigation.ListObjects.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.ListObjects.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Navigation.GetObjectInfoWithLinks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.protoMessageName + ".GetObjectInfoWithLinks"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks, rhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.GetObjectInfoWithLinks.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
    2: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.context != .navigation {
      try visitor.visitSingularEnumField(value: self.context, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Request, rhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Request) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.GetObjectInfoWithLinks.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "object"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response, rhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._object != rhs._object {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error, rhs: Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Navigation.GetObjectInfoWithLinks.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.History: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".History"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History, rhs: Anytype_Rpc.History) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Versions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.protoMessageName + ".Versions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Versions, rhs: Anytype_Rpc.History.Versions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Versions.Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Versions.protoMessageName + ".Version"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "previousIds"),
    3: .same(proto: "authorId"),
    4: .same(proto: "authorName"),
    5: .same(proto: "time"),
    6: .same(proto: "groupId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.previousIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authorName) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.previousIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.previousIds, fieldNumber: 2)
    }
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 3)
    }
    if !self.authorName.isEmpty {
      try visitor.visitSingularStringField(value: self.authorName, fieldNumber: 4)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 5)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt64Field(value: self.groupID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Versions.Version, rhs: Anytype_Rpc.History.Versions.Version) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.previousIds != rhs.previousIds {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs.authorName != rhs.authorName {return false}
    if lhs.time != rhs.time {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Versions.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Versions.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageId"),
    2: .same(proto: "lastVersionId"),
    3: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastVersionID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageID.isEmpty {
      try visitor.visitSingularStringField(value: self.pageID, fieldNumber: 1)
    }
    if !self.lastVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastVersionID, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Versions.Request, rhs: Anytype_Rpc.History.Versions.Request) -> Bool {
    if lhs.pageID != rhs.pageID {return false}
    if lhs.lastVersionID != rhs.lastVersionID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Versions.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Versions.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.versions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.versions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Versions.Response, rhs: Anytype_Rpc.History.Versions.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.versions != rhs.versions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Versions.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Versions.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Versions.Response.Error, rhs: Anytype_Rpc.History.Versions.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Versions.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.History.Show: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.protoMessageName + ".Show"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Show, rhs: Anytype_Rpc.History.Show) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Show.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Show.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageId"),
    2: .same(proto: "versionId"),
    3: .same(proto: "traceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageID.isEmpty {
      try visitor.visitSingularStringField(value: self.pageID, fieldNumber: 1)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 2)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Show.Request, rhs: Anytype_Rpc.History.Show.Request) -> Bool {
    if lhs.pageID != rhs.pageID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Show.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Show.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "objectShow"),
    3: .same(proto: "version"),
    4: .same(proto: "traceId"),
  ]

  fileprivate class _StorageClass {
    var _error: Anytype_Rpc.History.Show.Response.Error? = nil
    var _objectShow: Anytype_Event.Object.Show? = nil
    var _version: Anytype_Rpc.History.Versions.Version? = nil
    var _traceID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _error = source._error
      _objectShow = source._objectShow
      _version = source._version
      _traceID = source._traceID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._objectShow) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._traceID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._objectShow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._traceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._traceID, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Show.Response, rhs: Anytype_Rpc.History.Show.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._error != rhs_storage._error {return false}
        if _storage._objectShow != rhs_storage._objectShow {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._traceID != rhs_storage._traceID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Show.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.Show.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.Show.Response.Error, rhs: Anytype_Rpc.History.Show.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.Show.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.History.SetVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.protoMessageName + ".SetVersion"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.SetVersion, rhs: Anytype_Rpc.History.SetVersion) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.SetVersion.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.SetVersion.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageId"),
    2: .same(proto: "versionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageID.isEmpty {
      try visitor.visitSingularStringField(value: self.pageID, fieldNumber: 1)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.SetVersion.Request, rhs: Anytype_Rpc.History.SetVersion.Request) -> Bool {
    if lhs.pageID != rhs.pageID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.SetVersion.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.SetVersion.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.SetVersion.Response, rhs: Anytype_Rpc.History.SetVersion.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.SetVersion.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.History.SetVersion.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.History.SetVersion.Response.Error, rhs: Anytype_Rpc.History.SetVersion.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.History.SetVersion.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Page"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Page, rhs: Anytype_Rpc.Page) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Page.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Page.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Page.Create, rhs: Anytype_Rpc.Page.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Page.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Page.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Page.Create.Request, rhs: Anytype_Rpc.Page.Create.Request) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Page.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Page.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    3: .same(proto: "pageId"),
    4: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pageID.isEmpty {
      try visitor.visitSingularStringField(value: self.pageID, fieldNumber: 3)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Page.Create.Response, rhs: Anytype_Rpc.Page.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.pageID != rhs.pageID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Page.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Page.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Page.Create.Response.Error, rhs: Anytype_Rpc.Page.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Page.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Set"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Set, rhs: Anytype_Rpc.Set) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Set.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Set.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Set.Create, rhs: Anytype_Rpc.Set.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Set.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Set.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "details"),
    3: .same(proto: "templateId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.source.isEmpty {
      try visitor.visitRepeatedStringField(value: self.source, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Set.Create.Request, rhs: Anytype_Rpc.Set.Create.Request) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._details != rhs._details {return false}
    if lhs.templateID != rhs.templateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Set.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Set.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    3: .same(proto: "id"),
    4: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Set.Create.Response, rhs: Anytype_Rpc.Set.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.id != rhs.id {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Set.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Set.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Set.Create.Response.Error, rhs: Anytype_Rpc.Set.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Set.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
  ]
}

extension Anytype_Rpc.ObjectType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".ObjectType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType, rhs: Anytype_Rpc.ObjectType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.protoMessageName + ".List"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.List, rhs: Anytype_Rpc.ObjectType.List) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.List.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.List.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.List.Request, rhs: Anytype_Rpc.ObjectType.List.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.List.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.List.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "objectTypes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.objectTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.objectTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.List.Response, rhs: Anytype_Rpc.ObjectType.List.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.objectTypes != rhs.objectTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.List.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.List.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.List.Response.Error, rhs: Anytype_Rpc.ObjectType.List.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.List.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ObjectType.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.protoMessageName + ".Create"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Create, rhs: Anytype_Rpc.ObjectType.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Create.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Create.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._objectType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._objectType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Create.Request, rhs: Anytype_Rpc.ObjectType.Create.Request) -> Bool {
    if lhs._objectType != rhs._objectType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Create.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Create.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "objectType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._objectType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._objectType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Create.Response, rhs: Anytype_Rpc.ObjectType.Create.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._objectType != rhs._objectType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Create.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Create.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Create.Response.Error, rhs: Anytype_Rpc.ObjectType.Create.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Create.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
  ]
}

extension Anytype_Rpc.ObjectType.Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.protoMessageName + ".Relation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation, rhs: Anytype_Rpc.ObjectType.Relation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Add: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.protoMessageName + ".Add"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Add, rhs: Anytype_Rpc.ObjectType.Relation.Add) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Add.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Add.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectTypeUrl"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectTypeURL) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectTypeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.objectTypeURL, fieldNumber: 1)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Add.Request, rhs: Anytype_Rpc.ObjectType.Relation.Add.Request) -> Bool {
    if lhs.objectTypeURL != rhs.objectTypeURL {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Add.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Add.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Add.Response, rhs: Anytype_Rpc.ObjectType.Relation.Add.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Add.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Add.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Add.Response.Error, rhs: Anytype_Rpc.ObjectType.Relation.Add.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Add.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
    4: .same(proto: "READONLY_OBJECT_TYPE"),
  ]
}

extension Anytype_Rpc.ObjectType.Relation.Remove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.protoMessageName + ".Remove"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Remove, rhs: Anytype_Rpc.ObjectType.Relation.Remove) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Remove.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Remove.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectTypeUrl"),
    2: .same(proto: "relationKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectTypeURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectTypeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.objectTypeURL, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Remove.Request, rhs: Anytype_Rpc.ObjectType.Relation.Remove.Request) -> Bool {
    if lhs.objectTypeURL != rhs.objectTypeURL {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Remove.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Remove.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Remove.Response, rhs: Anytype_Rpc.ObjectType.Relation.Remove.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Remove.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Remove.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Remove.Response.Error, rhs: Anytype_Rpc.ObjectType.Relation.Remove.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Remove.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
    4: .same(proto: "READONLY_OBJECT_TYPE"),
  ]
}

extension Anytype_Rpc.ObjectType.Relation.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.protoMessageName + ".Update"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Update, rhs: Anytype_Rpc.ObjectType.Relation.Update) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Update.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Update.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectTypeUrl"),
    2: .same(proto: "relation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectTypeURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._relation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.objectTypeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.objectTypeURL, fieldNumber: 1)
    }
    try { if let v = self._relation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Update.Request, rhs: Anytype_Rpc.ObjectType.Relation.Update.Request) -> Bool {
    if lhs.objectTypeURL != rhs.objectTypeURL {return false}
    if lhs._relation != rhs._relation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Update.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Update.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Update.Response, rhs: Anytype_Rpc.ObjectType.Relation.Update.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Update.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.Update.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.Update.Response.Error, rhs: Anytype_Rpc.ObjectType.Relation.Update.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.Update.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
    4: .same(proto: "READONLY_OBJECT_TYPE"),
  ]
}

extension Anytype_Rpc.ObjectType.Relation.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.protoMessageName + ".List"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.List, rhs: Anytype_Rpc.ObjectType.Relation.List) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.List.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.List.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectTypeUrl"),
    2: .same(proto: "appendRelationsFromOtherTypes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectTypeURL) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.appendRelationsFromOtherTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectTypeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.objectTypeURL, fieldNumber: 1)
    }
    if self.appendRelationsFromOtherTypes != false {
      try visitor.visitSingularBoolField(value: self.appendRelationsFromOtherTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.List.Request, rhs: Anytype_Rpc.ObjectType.Relation.List.Request) -> Bool {
    if lhs.objectTypeURL != rhs.objectTypeURL {return false}
    if lhs.appendRelationsFromOtherTypes != rhs.appendRelationsFromOtherTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.List.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.List.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.List.Response, rhs: Anytype_Rpc.ObjectType.Relation.List.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.List.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectType.Relation.List.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectType.Relation.List.Response.Error, rhs: Anytype_Rpc.ObjectType.Relation.List.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectType.Relation.List.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "UNKNOWN_OBJECT_TYPE_URL"),
  ]
}

extension Anytype_Rpc.Object: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Object"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object, rhs: Anytype_Rpc.Object) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ShareByLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".ShareByLink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ShareByLink, rhs: Anytype_Rpc.Object.ShareByLink) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ShareByLink.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.ShareByLink.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ShareByLink.Request, rhs: Anytype_Rpc.Object.ShareByLink.Request) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ShareByLink.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.ShareByLink.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "link"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.link) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ShareByLink.Response, rhs: Anytype_Rpc.Object.ShareByLink.Response) -> Bool {
    if lhs.link != rhs.link {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ShareByLink.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.ShareByLink.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ShareByLink.Response.Error, rhs: Anytype_Rpc.Object.ShareByLink.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ShareByLink.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.AddWithObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".AddWithObjectId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.AddWithObjectId, rhs: Anytype_Rpc.Object.AddWithObjectId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.AddWithObjectId.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.AddWithObjectId.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.AddWithObjectId.Request, rhs: Anytype_Rpc.Object.AddWithObjectId.Request) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.AddWithObjectId.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.AddWithObjectId.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.AddWithObjectId.Response, rhs: Anytype_Rpc.Object.AddWithObjectId.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.AddWithObjectId.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.AddWithObjectId.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.AddWithObjectId.Response.Error, rhs: Anytype_Rpc.Object.AddWithObjectId.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.AddWithObjectId.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.RelationAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationAdd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationAdd, rhs: Anytype_Rpc.Object.RelationAdd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationAdd.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationAdd.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._relation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    try { if let v = self._relation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationAdd.Request, rhs: Anytype_Rpc.Object.RelationAdd.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs._relation != rhs._relation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationAdd.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationAdd.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "relationKey"),
    4: .same(proto: "relation"),
  ]

  fileprivate class _StorageClass {
    var _error: Anytype_Rpc.Object.RelationAdd.Response.Error? = nil
    var _event: Anytype_ResponseEvent? = nil
    var _relationKey: String = String()
    var _relation: Anytype_Model_Relation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _error = source._error
      _event = source._event
      _relationKey = source._relationKey
      _relation = source._relation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._relationKey) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._relation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._relationKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relationKey, fieldNumber: 3)
      }
      try { if let v = _storage._relation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationAdd.Response, rhs: Anytype_Rpc.Object.RelationAdd.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._error != rhs_storage._error {return false}
        if _storage._event != rhs_storage._event {return false}
        if _storage._relationKey != rhs_storage._relationKey {return false}
        if _storage._relation != rhs_storage._relation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationAdd.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationAdd.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationAdd.Response.Error, rhs: Anytype_Rpc.Object.RelationAdd.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationAdd.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.RelationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationUpdate, rhs: Anytype_Rpc.Object.RelationUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relationKey"),
    3: .same(proto: "relation"),
  ]

  fileprivate class _StorageClass {
    var _contextID: String = String()
    var _relationKey: String = String()
    var _relation: Anytype_Model_Relation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contextID = source._contextID
      _relationKey = source._relationKey
      _relation = source._relation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contextID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._relationKey) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._relation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._contextID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contextID, fieldNumber: 1)
      }
      if !_storage._relationKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relationKey, fieldNumber: 2)
      }
      try { if let v = _storage._relation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationUpdate.Request, rhs: Anytype_Rpc.Object.RelationUpdate.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contextID != rhs_storage._contextID {return false}
        if _storage._relationKey != rhs_storage._relationKey {return false}
        if _storage._relation != rhs_storage._relation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationUpdate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationUpdate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationUpdate.Response, rhs: Anytype_Rpc.Object.RelationUpdate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationUpdate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationUpdate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationUpdate.Response.Error, rhs: Anytype_Rpc.Object.RelationUpdate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationUpdate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.RelationDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationDelete, rhs: Anytype_Rpc.Object.RelationDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationDelete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationDelete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relationKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationDelete.Request, rhs: Anytype_Rpc.Object.RelationDelete.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationDelete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationDelete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationDelete.Response, rhs: Anytype_Rpc.Object.RelationDelete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationDelete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationDelete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationDelete.Response.Error, rhs: Anytype_Rpc.Object.RelationDelete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationDelete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.RelationOptionAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationOptionAdd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionAdd, rhs: Anytype_Rpc.Object.RelationOptionAdd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionAdd.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionAdd.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relationKey"),
    3: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionAdd.Request, rhs: Anytype_Rpc.Object.RelationOptionAdd.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionAdd.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionAdd.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
    3: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionAdd.Response, rhs: Anytype_Rpc.Object.RelationOptionAdd.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionAdd.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionAdd.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionAdd.Response.Error, rhs: Anytype_Rpc.Object.RelationOptionAdd.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionAdd.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.RelationOptionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationOptionUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionUpdate, rhs: Anytype_Rpc.Object.RelationOptionUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relationKey"),
    3: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionUpdate.Request, rhs: Anytype_Rpc.Object.RelationOptionUpdate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionUpdate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionUpdate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionUpdate.Response, rhs: Anytype_Rpc.Object.RelationOptionUpdate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionUpdate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionUpdate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionUpdate.Response.Error, rhs: Anytype_Rpc.Object.RelationOptionUpdate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionUpdate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.RelationOptionDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationOptionDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionDelete, rhs: Anytype_Rpc.Object.RelationOptionDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionDelete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionDelete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relationKey"),
    3: .same(proto: "optionId"),
    4: .same(proto: "confirmRemoveAllValuesInRecords"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.optionID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.confirmRemoveAllValuesInRecords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    if !self.optionID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionID, fieldNumber: 3)
    }
    if self.confirmRemoveAllValuesInRecords != false {
      try visitor.visitSingularBoolField(value: self.confirmRemoveAllValuesInRecords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionDelete.Request, rhs: Anytype_Rpc.Object.RelationOptionDelete.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.optionID != rhs.optionID {return false}
    if lhs.confirmRemoveAllValuesInRecords != rhs.confirmRemoveAllValuesInRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionDelete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionDelete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionDelete.Response, rhs: Anytype_Rpc.Object.RelationOptionDelete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionDelete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationOptionDelete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationOptionDelete.Response.Error, rhs: Anytype_Rpc.Object.RelationOptionDelete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationOptionDelete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
    3: .same(proto: "SOME_RECORDS_HAS_RELATION_VALUE_WITH_THIS_OPTION"),
  ]
}

extension Anytype_Rpc.Object.RelationListAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".RelationListAvailable"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationListAvailable, rhs: Anytype_Rpc.Object.RelationListAvailable) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationListAvailable.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationListAvailable.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationListAvailable.Request, rhs: Anytype_Rpc.Object.RelationListAvailable.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationListAvailable.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationListAvailable.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationListAvailable.Response, rhs: Anytype_Rpc.Object.RelationListAvailable.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationListAvailable.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.RelationListAvailable.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.RelationListAvailable.Response.Error, rhs: Anytype_Rpc.Object.RelationListAvailable.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.RelationListAvailable.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.Search: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".Search"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Search, rhs: Anytype_Rpc.Object.Search) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Search.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Search.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
    2: .same(proto: "sorts"),
    3: .same(proto: "fullText"),
    4: .same(proto: "offset"),
    5: .same(proto: "limit"),
    6: .same(proto: "objectTypeFilter"),
    7: .same(proto: "keys"),
    8: .same(proto: "ignoreWorkspace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullText) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.objectTypeFilter) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.ignoreWorkspace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    if !self.sorts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sorts, fieldNumber: 2)
    }
    if !self.fullText.isEmpty {
      try visitor.visitSingularStringField(value: self.fullText, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 4)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 5)
    }
    if !self.objectTypeFilter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectTypeFilter, fieldNumber: 6)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 7)
    }
    if self.ignoreWorkspace != false {
      try visitor.visitSingularBoolField(value: self.ignoreWorkspace, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Search.Request, rhs: Anytype_Rpc.Object.Search.Request) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.sorts != rhs.sorts {return false}
    if lhs.fullText != rhs.fullText {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.objectTypeFilter != rhs.objectTypeFilter {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.ignoreWorkspace != rhs.ignoreWorkspace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Search.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Search.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Search.Response, rhs: Anytype_Rpc.Object.Search.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Search.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Search.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Search.Response.Error, rhs: Anytype_Rpc.Object.Search.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Search.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.Graph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".Graph"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Graph, rhs: Anytype_Rpc.Object.Graph) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Graph.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Graph.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
    2: .same(proto: "limit"),
    3: .same(proto: "objectTypeFilter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.objectTypeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.objectTypeFilter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectTypeFilter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Graph.Request, rhs: Anytype_Rpc.Object.Graph.Request) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.objectTypeFilter != rhs.objectTypeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Graph.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Graph.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "layout"),
    5: .same(proto: "description"),
    6: .same(proto: "iconImage"),
    7: .same(proto: "iconEmoji"),
    8: .same(proto: "done"),
    9: .same(proto: "relationFormat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.layout) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.iconImage) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.iconEmoji) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.relationFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.layout != 0 {
      try visitor.visitSingularInt32Field(value: self.layout, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.iconImage.isEmpty {
      try visitor.visitSingularStringField(value: self.iconImage, fieldNumber: 6)
    }
    if !self.iconEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.iconEmoji, fieldNumber: 7)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 8)
    }
    if self.relationFormat != 0 {
      try visitor.visitSingularInt32Field(value: self.relationFormat, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Graph.Node, rhs: Anytype_Rpc.Object.Graph.Node) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.layout != rhs.layout {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.iconImage != rhs.iconImage {return false}
    if lhs.iconEmoji != rhs.iconEmoji {return false}
    if lhs.done != rhs.done {return false}
    if lhs.relationFormat != rhs.relationFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Graph.Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Graph.protoMessageName + ".Edge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "target"),
    3: .same(proto: "name"),
    4: .same(proto: "type"),
    5: .same(proto: "description"),
    6: .same(proto: "iconImage"),
    7: .same(proto: "iconEmoji"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.iconImage) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.iconEmoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.type != .link {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.iconImage.isEmpty {
      try visitor.visitSingularStringField(value: self.iconImage, fieldNumber: 6)
    }
    if !self.iconEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.iconEmoji, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Graph.Edge, rhs: Anytype_Rpc.Object.Graph.Edge) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.target != rhs.target {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.iconImage != rhs.iconImage {return false}
    if lhs.iconEmoji != rhs.iconEmoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Graph.Edge.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Link"),
    1: .same(proto: "Relation"),
  ]
}

extension Anytype_Rpc.Object.Graph.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Graph.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "nodes"),
    3: .same(proto: "edges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.edges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 2)
    }
    if !self.edges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edges, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Graph.Response, rhs: Anytype_Rpc.Object.Graph.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.edges != rhs.edges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Graph.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.Graph.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.Graph.Response.Error, rhs: Anytype_Rpc.Object.Graph.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.Graph.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.SetLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".SetLayout"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetLayout, rhs: Anytype_Rpc.Object.SetLayout) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetLayout.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetLayout.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    3: .same(proto: "layout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.layout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if self.layout != .basic {
      try visitor.visitSingularEnumField(value: self.layout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetLayout.Request, rhs: Anytype_Rpc.Object.SetLayout.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.layout != rhs.layout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetLayout.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetLayout.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetLayout.Response, rhs: Anytype_Rpc.Object.SetLayout.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetLayout.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetLayout.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetLayout.Response.Error, rhs: Anytype_Rpc.Object.SetLayout.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetLayout.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.SetIsFavorite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".SetIsFavorite"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsFavorite, rhs: Anytype_Rpc.Object.SetIsFavorite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsFavorite.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetIsFavorite.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "isFavorite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isFavorite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if self.isFavorite != false {
      try visitor.visitSingularBoolField(value: self.isFavorite, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsFavorite.Request, rhs: Anytype_Rpc.Object.SetIsFavorite.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.isFavorite != rhs.isFavorite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsFavorite.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetIsFavorite.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsFavorite.Response, rhs: Anytype_Rpc.Object.SetIsFavorite.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsFavorite.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetIsFavorite.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsFavorite.Response.Error, rhs: Anytype_Rpc.Object.SetIsFavorite.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsFavorite.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.SetIsArchived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".SetIsArchived"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsArchived, rhs: Anytype_Rpc.Object.SetIsArchived) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsArchived.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetIsArchived.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "isArchived"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsArchived.Request, rhs: Anytype_Rpc.Object.SetIsArchived.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsArchived.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetIsArchived.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsArchived.Response, rhs: Anytype_Rpc.Object.SetIsArchived.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsArchived.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.SetIsArchived.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.SetIsArchived.Response.Error, rhs: Anytype_Rpc.Object.SetIsArchived.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.SetIsArchived.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.FeaturedRelation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".FeaturedRelation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation, rhs: Anytype_Rpc.Object.FeaturedRelation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Add: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.protoMessageName + ".Add"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Add, rhs: Anytype_Rpc.Object.FeaturedRelation.Add) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Add.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.Add.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Add.Request, rhs: Anytype_Rpc.Object.FeaturedRelation.Add.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Add.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.Add.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Add.Response, rhs: Anytype_Rpc.Object.FeaturedRelation.Add.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.Add.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error, rhs: Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Add.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.FeaturedRelation.Remove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.protoMessageName + ".Remove"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Remove, rhs: Anytype_Rpc.Object.FeaturedRelation.Remove) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Remove.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.Remove.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.relations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Remove.Request, rhs: Anytype_Rpc.Object.FeaturedRelation.Remove.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Remove.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.Remove.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Remove.Response, rhs: Anytype_Rpc.Object.FeaturedRelation.Remove.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.FeaturedRelation.Remove.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error, rhs: Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.FeaturedRelation.Remove.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Object.ToSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.protoMessageName + ".ToSet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ToSet, rhs: Anytype_Rpc.Object.ToSet) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ToSet.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.ToSet.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitRepeatedStringField(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ToSet.Request, rhs: Anytype_Rpc.Object.ToSet.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ToSet.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.ToSet.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "setId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.setID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.setID.isEmpty {
      try visitor.visitSingularStringField(value: self.setID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ToSet.Response, rhs: Anytype_Rpc.Object.ToSet.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.setID != rhs.setID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ToSet.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Object.ToSet.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Object.ToSet.Response.Error, rhs: Anytype_Rpc.Object.ToSet.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Object.ToSet.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ObjectList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".ObjectList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList, rhs: Anytype_Rpc.ObjectList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.protoMessageName + ".Delete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Delete, rhs: Anytype_Rpc.ObjectList.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Delete.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Delete.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.objectIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Delete.Request, rhs: Anytype_Rpc.ObjectList.Delete.Request) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Delete.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Delete.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Delete.Response, rhs: Anytype_Rpc.ObjectList.Delete.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Delete.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Delete.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Delete.Response.Error, rhs: Anytype_Rpc.ObjectList.Delete.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Delete.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ObjectList.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.protoMessageName + ".Set"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set, rhs: Anytype_Rpc.ObjectList.Set) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsArchived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.protoMessageName + ".IsArchived"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsArchived, rhs: Anytype_Rpc.ObjectList.Set.IsArchived) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsArchived.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.IsArchived.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectIds"),
    2: .same(proto: "isArchived"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.objectIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectIds, fieldNumber: 1)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsArchived.Request, rhs: Anytype_Rpc.ObjectList.Set.IsArchived.Request) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsArchived.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.IsArchived.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsArchived.Response, rhs: Anytype_Rpc.ObjectList.Set.IsArchived.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.IsArchived.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error, rhs: Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsArchived.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ObjectList.Set.IsFavorite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.protoMessageName + ".IsFavorite"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsFavorite, rhs: Anytype_Rpc.ObjectList.Set.IsFavorite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsFavorite.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.IsFavorite.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectIds"),
    2: .same(proto: "isFavorite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.objectIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isFavorite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectIds, fieldNumber: 1)
    }
    if self.isFavorite != false {
      try visitor.visitSingularBoolField(value: self.isFavorite, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsFavorite.Request, rhs: Anytype_Rpc.ObjectList.Set.IsFavorite.Request) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.isFavorite != rhs.isFavorite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsFavorite.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.IsFavorite.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsFavorite.Response, rhs: Anytype_Rpc.ObjectList.Set.IsFavorite.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ObjectList.Set.IsFavorite.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error, rhs: Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ObjectList.Set.IsFavorite.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Export: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Export"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Export, rhs: Anytype_Rpc.Export) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Export.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Markdown"),
    1: .same(proto: "Protobuf"),
    2: .same(proto: "JSON"),
    3: .same(proto: "DOT"),
    4: .same(proto: "SVG"),
    5: .same(proto: "GRAPH_JSON"),
  ]
}

extension Anytype_Rpc.Export.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Export.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "docIds"),
    3: .same(proto: "format"),
    4: .same(proto: "zip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.docIds) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.zip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.docIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.docIds, fieldNumber: 2)
    }
    if self.format != .markdown {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    if self.zip != false {
      try visitor.visitSingularBoolField(value: self.zip, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Export.Request, rhs: Anytype_Rpc.Export.Request) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.docIds != rhs.docIds {return false}
    if lhs.format != rhs.format {return false}
    if lhs.zip != rhs.zip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Export.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Export.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "path"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Export.Response, rhs: Anytype_Rpc.Export.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.path != rhs.path {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Export.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Export.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Export.Response.Error, rhs: Anytype_Rpc.Export.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Export.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ExportTemplates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".ExportTemplates"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportTemplates, rhs: Anytype_Rpc.ExportTemplates) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportTemplates.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExportTemplates.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportTemplates.Request, rhs: Anytype_Rpc.ExportTemplates.Request) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportTemplates.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExportTemplates.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "path"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportTemplates.Response, rhs: Anytype_Rpc.ExportTemplates.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.path != rhs.path {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportTemplates.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExportTemplates.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportTemplates.Response.Error, rhs: Anytype_Rpc.ExportTemplates.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportTemplates.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ExportLocalstore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".ExportLocalstore"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportLocalstore, rhs: Anytype_Rpc.ExportLocalstore) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportLocalstore.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExportLocalstore.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "docIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.docIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.docIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.docIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportLocalstore.Request, rhs: Anytype_Rpc.ExportLocalstore.Request) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.docIds != rhs.docIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportLocalstore.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExportLocalstore.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "path"),
    3: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportLocalstore.Response, rhs: Anytype_Rpc.ExportLocalstore.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.path != rhs.path {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportLocalstore.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ExportLocalstore.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ExportLocalstore.Response.Error, rhs: Anytype_Rpc.ExportLocalstore.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ExportLocalstore.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.MakeTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".MakeTemplate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplate, rhs: Anytype_Rpc.MakeTemplate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.MakeTemplate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplate.Request, rhs: Anytype_Rpc.MakeTemplate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.MakeTemplate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplate.Response, rhs: Anytype_Rpc.MakeTemplate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.MakeTemplate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplate.Response.Error, rhs: Anytype_Rpc.MakeTemplate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.MakeTemplateByObjectType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".MakeTemplateByObjectType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplateByObjectType, rhs: Anytype_Rpc.MakeTemplateByObjectType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplateByObjectType.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.MakeTemplateByObjectType.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectType.isEmpty {
      try visitor.visitSingularStringField(value: self.objectType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplateByObjectType.Request, rhs: Anytype_Rpc.MakeTemplateByObjectType.Request) -> Bool {
    if lhs.objectType != rhs.objectType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplateByObjectType.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.MakeTemplateByObjectType.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplateByObjectType.Response, rhs: Anytype_Rpc.MakeTemplateByObjectType.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplateByObjectType.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.MakeTemplateByObjectType.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.MakeTemplateByObjectType.Response.Error, rhs: Anytype_Rpc.MakeTemplateByObjectType.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.MakeTemplateByObjectType.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.CloneTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".CloneTemplate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.CloneTemplate, rhs: Anytype_Rpc.CloneTemplate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.CloneTemplate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.CloneTemplate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.CloneTemplate.Request, rhs: Anytype_Rpc.CloneTemplate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.CloneTemplate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.CloneTemplate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.CloneTemplate.Response, rhs: Anytype_Rpc.CloneTemplate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.CloneTemplate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.CloneTemplate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.CloneTemplate.Response.Error, rhs: Anytype_Rpc.CloneTemplate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.CloneTemplate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.ApplyTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".ApplyTemplate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ApplyTemplate, rhs: Anytype_Rpc.ApplyTemplate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ApplyTemplate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ApplyTemplate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contextId"),
    2: .same(proto: "templateId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 1)
    }
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ApplyTemplate.Request, rhs: Anytype_Rpc.ApplyTemplate.Request) -> Bool {
    if lhs.contextID != rhs.contextID {return false}
    if lhs.templateID != rhs.templateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ApplyTemplate.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ApplyTemplate.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ApplyTemplate.Response, rhs: Anytype_Rpc.ApplyTemplate.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ApplyTemplate.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.ApplyTemplate.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.ApplyTemplate.Response.Error, rhs: Anytype_Rpc.ApplyTemplate.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.ApplyTemplate.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Debug: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".Debug"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug, rhs: Anytype_Rpc.Debug) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.logInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.protoMessageName + ".logInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "head"),
    3: .same(proto: "headDownloaded"),
    4: .same(proto: "totalRecords"),
    5: .same(proto: "totalSize"),
    6: .same(proto: "firstRecordTs"),
    7: .same(proto: "firstRecordVer"),
    8: .same(proto: "lastRecordTs"),
    9: .same(proto: "lastRecordVer"),
    10: .same(proto: "lastPullSecAgo"),
    11: .same(proto: "upStatus"),
    12: .same(proto: "downStatus"),
    13: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.head) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.headDownloaded) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalRecords) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.firstRecordTs) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.firstRecordVer) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.lastRecordTs) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.lastRecordVer) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.lastPullSecAgo) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.upStatus) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.downStatus) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.head.isEmpty {
      try visitor.visitSingularStringField(value: self.head, fieldNumber: 2)
    }
    if self.headDownloaded != false {
      try visitor.visitSingularBoolField(value: self.headDownloaded, fieldNumber: 3)
    }
    if self.totalRecords != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRecords, fieldNumber: 4)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 5)
    }
    if self.firstRecordTs != 0 {
      try visitor.visitSingularInt32Field(value: self.firstRecordTs, fieldNumber: 6)
    }
    if self.firstRecordVer != 0 {
      try visitor.visitSingularInt32Field(value: self.firstRecordVer, fieldNumber: 7)
    }
    if self.lastRecordTs != 0 {
      try visitor.visitSingularInt32Field(value: self.lastRecordTs, fieldNumber: 8)
    }
    if self.lastRecordVer != 0 {
      try visitor.visitSingularInt32Field(value: self.lastRecordVer, fieldNumber: 9)
    }
    if self.lastPullSecAgo != 0 {
      try visitor.visitSingularInt32Field(value: self.lastPullSecAgo, fieldNumber: 10)
    }
    if !self.upStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.upStatus, fieldNumber: 11)
    }
    if !self.downStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.downStatus, fieldNumber: 12)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.logInfo, rhs: Anytype_Rpc.Debug.logInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.head != rhs.head {return false}
    if lhs.headDownloaded != rhs.headDownloaded {return false}
    if lhs.totalRecords != rhs.totalRecords {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.firstRecordTs != rhs.firstRecordTs {return false}
    if lhs.firstRecordVer != rhs.firstRecordVer {return false}
    if lhs.lastRecordTs != rhs.lastRecordTs {return false}
    if lhs.lastRecordVer != rhs.lastRecordVer {return false}
    if lhs.lastPullSecAgo != rhs.lastPullSecAgo {return false}
    if lhs.upStatus != rhs.upStatus {return false}
    if lhs.downStatus != rhs.downStatus {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.threadInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.protoMessageName + ".threadInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "logsWithDownloadedHead"),
    3: .same(proto: "logsWithWholeTreeDownloaded"),
    4: .same(proto: "logs"),
    5: .same(proto: "ownLogHasCafeReplicator"),
    6: .same(proto: "cafeLastPullSecAgo"),
    7: .same(proto: "cafeUpStatus"),
    8: .same(proto: "cafeDownStatus"),
    9: .same(proto: "totalRecords"),
    10: .same(proto: "totalSize"),
    11: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.logsWithDownloadedHead) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.logsWithWholeTreeDownloaded) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.ownLogHasCafeReplicator) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cafeLastPullSecAgo) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.cafeUpStatus) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cafeDownStatus) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.totalRecords) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.logsWithDownloadedHead != 0 {
      try visitor.visitSingularInt32Field(value: self.logsWithDownloadedHead, fieldNumber: 2)
    }
    if self.logsWithWholeTreeDownloaded != 0 {
      try visitor.visitSingularInt32Field(value: self.logsWithWholeTreeDownloaded, fieldNumber: 3)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 4)
    }
    if self.ownLogHasCafeReplicator != false {
      try visitor.visitSingularBoolField(value: self.ownLogHasCafeReplicator, fieldNumber: 5)
    }
    if self.cafeLastPullSecAgo != 0 {
      try visitor.visitSingularInt32Field(value: self.cafeLastPullSecAgo, fieldNumber: 6)
    }
    if !self.cafeUpStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeUpStatus, fieldNumber: 7)
    }
    if !self.cafeDownStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeDownStatus, fieldNumber: 8)
    }
    if self.totalRecords != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRecords, fieldNumber: 9)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 10)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.threadInfo, rhs: Anytype_Rpc.Debug.threadInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.logsWithDownloadedHead != rhs.logsWithDownloadedHead {return false}
    if lhs.logsWithWholeTreeDownloaded != rhs.logsWithWholeTreeDownloaded {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.ownLogHasCafeReplicator != rhs.ownLogHasCafeReplicator {return false}
    if lhs.cafeLastPullSecAgo != rhs.cafeLastPullSecAgo {return false}
    if lhs.cafeUpStatus != rhs.cafeUpStatus {return false}
    if lhs.cafeDownStatus != rhs.cafeDownStatus {return false}
    if lhs.totalRecords != rhs.totalRecords {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Sync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.protoMessageName + ".Sync"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Sync, rhs: Anytype_Rpc.Debug.Sync) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Sync.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Sync.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recordsTraverseLimit"),
    2: .same(proto: "skipEmptyLogs"),
    3: .same(proto: "tryToDownloadRemoteRecords"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.recordsTraverseLimit) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.skipEmptyLogs) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tryToDownloadRemoteRecords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.recordsTraverseLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.recordsTraverseLimit, fieldNumber: 1)
    }
    if self.skipEmptyLogs != false {
      try visitor.visitSingularBoolField(value: self.skipEmptyLogs, fieldNumber: 2)
    }
    if self.tryToDownloadRemoteRecords != false {
      try visitor.visitSingularBoolField(value: self.tryToDownloadRemoteRecords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Sync.Request, rhs: Anytype_Rpc.Debug.Sync.Request) -> Bool {
    if lhs.recordsTraverseLimit != rhs.recordsTraverseLimit {return false}
    if lhs.skipEmptyLogs != rhs.skipEmptyLogs {return false}
    if lhs.tryToDownloadRemoteRecords != rhs.tryToDownloadRemoteRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Sync.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Sync.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "threads"),
    3: .same(proto: "deviceId"),
    4: .same(proto: "totalThreads"),
    5: .same(proto: "threadsWithoutReplInOwnLog"),
    6: .same(proto: "threadsWithoutHeadDownloaded"),
    7: .same(proto: "totalRecords"),
    8: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.threads) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalThreads) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.threadsWithoutReplInOwnLog) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.threadsWithoutHeadDownloaded) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.totalRecords) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.threads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.threads, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 3)
    }
    if self.totalThreads != 0 {
      try visitor.visitSingularInt32Field(value: self.totalThreads, fieldNumber: 4)
    }
    if self.threadsWithoutReplInOwnLog != 0 {
      try visitor.visitSingularInt32Field(value: self.threadsWithoutReplInOwnLog, fieldNumber: 5)
    }
    if self.threadsWithoutHeadDownloaded != 0 {
      try visitor.visitSingularInt32Field(value: self.threadsWithoutHeadDownloaded, fieldNumber: 6)
    }
    if self.totalRecords != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRecords, fieldNumber: 7)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Sync.Response, rhs: Anytype_Rpc.Debug.Sync.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.threads != rhs.threads {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.totalThreads != rhs.totalThreads {return false}
    if lhs.threadsWithoutReplInOwnLog != rhs.threadsWithoutReplInOwnLog {return false}
    if lhs.threadsWithoutHeadDownloaded != rhs.threadsWithoutHeadDownloaded {return false}
    if lhs.totalRecords != rhs.totalRecords {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Sync.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Sync.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Sync.Response.Error, rhs: Anytype_Rpc.Debug.Sync.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Sync.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Debug.Thread: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.protoMessageName + ".Thread"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Thread, rhs: Anytype_Rpc.Debug.Thread) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Thread.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Thread.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threadId"),
    2: .same(proto: "skipEmptyLogs"),
    3: .same(proto: "tryToDownloadRemoteRecords"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.skipEmptyLogs) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tryToDownloadRemoteRecords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if self.skipEmptyLogs != false {
      try visitor.visitSingularBoolField(value: self.skipEmptyLogs, fieldNumber: 2)
    }
    if self.tryToDownloadRemoteRecords != false {
      try visitor.visitSingularBoolField(value: self.tryToDownloadRemoteRecords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Thread.Request, rhs: Anytype_Rpc.Debug.Thread.Request) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.skipEmptyLogs != rhs.skipEmptyLogs {return false}
    if lhs.tryToDownloadRemoteRecords != rhs.tryToDownloadRemoteRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Thread.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Thread.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Thread.Response, rhs: Anytype_Rpc.Debug.Thread.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Thread.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Thread.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Thread.Response.Error, rhs: Anytype_Rpc.Debug.Thread.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Thread.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.Debug.Tree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.protoMessageName + ".Tree"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Tree, rhs: Anytype_Rpc.Debug.Tree) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Tree.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Tree.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockId"),
    2: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.blockID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockID, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Tree.Request, rhs: Anytype_Rpc.Debug.Tree.Request) -> Bool {
    if lhs.blockID != rhs.blockID {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Tree.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Tree.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Tree.Response, rhs: Anytype_Rpc.Debug.Tree.Response) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Tree.Response.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.Debug.Tree.Response.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.Debug.Tree.Response.Error, rhs: Anytype_Rpc.Debug.Tree.Response.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.Debug.Tree.Response.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Rpc.GenericErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.protoMessageName + ".GenericErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.GenericErrorResponse, rhs: Anytype_Rpc.GenericErrorResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.GenericErrorResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Rpc.GenericErrorResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .null {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Rpc.GenericErrorResponse.Error, rhs: Anytype_Rpc.GenericErrorResponse.Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Rpc.GenericErrorResponse.Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "BAD_INPUT"),
  ]
}

extension Anytype_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Empty, rhs: Anytype_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
